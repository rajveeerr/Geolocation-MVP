This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.cursor/rules/api-patterns.mdc
.cursor/rules/auth-security.mdc
.cursor/rules/database-patterns.mdc
.cursor/rules/deal-categories.mdc
.cursor/rules/development-workflow.mdc
.cursor/rules/error-handling.mdc
.cursor/rules/geolocation-features.mdc
.cursor/rules/project-structure.mdc
.cursor/rules/typescript-standards.mdc
.gitignore
docker-compose.prod.yml
Dockerfile.prod
docs/cities.md
docs/merchant-approval.md
env.production.example
jest.config.ts
nodemon.json
package.json
prisma/migrations/20250719140239_init/migration.sql
prisma/migrations/20250807075826_add_merchant_deal_approval_flow/migration.sql
prisma/migrations/20250826180232_add_merchant_geolocation/migration.sql
prisma/migrations/20250826180807_add_deal_categories/migration.sql
prisma/migrations/20250826190000_add_performance_indexes/migration.sql
prisma/migrations/20250909133522_add_deal_type_and_recurring_days/migration.sql
prisma/migrations/20250911101651_add_user_points_column/migration.sql
prisma/migrations/20250911103117_add_gamification_and_checkins/migration.sql
prisma/migrations/20250911115350_leaderboard/migration.sql
prisma/migrations/20250911120000_add_leaderboard_indexes/migration.sql
prisma/migrations/20250911123000_add_monthly_points_column/migration.sql
prisma/migrations/20250911124500_add_covering_index_userpointevent/migration.sql
prisma/migrations/20250911130000_add_referral_code/migration.sql
prisma/migrations/20250911131500_add_user_referrals/migration.sql
prisma/migrations/20250911133000_add_user_birthday/migration.sql
prisma/migrations/20250918194506_referral/migration.sql
prisma/migrations/migration_lock.toml
prisma/schema.prisma
README_PROD.md
scripts/backfill-merchant-stores.ts
scripts/backfill-referral-codes.ts
scripts/db-health-check.ts
scripts/manual-create-city-store.ts
scripts/seed-cities.ts
src/app.ts
src/index.ts
src/jobs/dailyBirthday.ts
src/jobs/monthlyReset.ts
src/lib/email.ts
src/lib/leaderboard/cache.ts
src/lib/leaderboard/leaderboard.ts
src/lib/leaderboard/period.ts
src/lib/logging/logger.ts
src/lib/metrics.ts
src/lib/points.ts
src/lib/prisma.ts
src/middleware/auth.middleware.ts
src/middleware/production.middleware.ts
src/routes/admin.routes.ts
src/routes/auth.routes.ts
src/routes/cities.routes.ts
src/routes/deals.public.routes.ts
src/routes/health.routes.ts
src/routes/leaderboard.routes.ts
src/routes/merchant.routes.ts
src/routes/user.routes.ts
src/types/winston-daily-rotate-file.d.ts
tests/admin.merchant.approval.test.ts
tests/checkin.points.test.ts
tests/leaderboard.test.ts
tests/referral.success.email.test.ts
tests/referral.test.ts
tests/referrals.endpoint.test.ts
tests/setup.ts
tests/welcome.email.test.ts
tsconfig.json
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".cursor/rules/api-patterns.mdc">
---
globs: src/routes/*.ts
description: API patterns and conventions for Express routes
---

# API Patterns and Conventions

## Route Structure

- **Base Path**: All API routes use `/api` prefix
- **Resource Naming**: Use plural nouns (e.g., `/api/deals`, `/api/merchants`)
- **Nested Resources**: Use clear hierarchy (e.g., `/api/merchants/register`)

## HTTP Methods and Status Codes

- **GET**: Retrieve data (200, 404)
- **POST**: Create resources (201, 400, 409)
- **PUT**: Update resources (200, 400, 404)
- **DELETE**: Remove resources (204, 404)

## Response Format

```typescript
// Success responses
res.status(201).json({
  message: 'Resource created successfully',
  data: resourceData
});

// Error responses
res.status(400).json({ 
  error: 'Descriptive error message' 
});

// Validation errors
res.status(400).json({ 
  errors: zodError.issues 
});
```

## Authentication Patterns

- **Public Routes**: No authentication required (e.g., deal discovery)
- **Protected Routes**: Use `protect` middleware for user authentication
- **Merchant Routes**: Use `isApprovedMerchant` middleware for merchant-only operations

## Input Validation

- Use Zod schemas for request validation
- Validate all required fields
- Sanitize and validate geolocation coordinates
- Check enum values against defined constants

## Query Parameters

- **Geolocation**: `latitude`, `longitude`, `radius` for location-based filtering
- **Filtering**: `category`, `search` for content filtering
- **Pagination**: Consider adding `limit`, `offset` for large datasets

## Performance Considerations

- Log query performance for optimization
- Use database indexes efficiently
- Implement proper error boundaries
- Consider caching for frequently accessed data
</file>

<file path=".cursor/rules/auth-security.mdc">
---
globs: src/middleware/auth.middleware.ts,src/routes/auth.routes.ts
description: Authentication and security patterns
---

# Authentication and Security Patterns

## JWT Implementation

- **Secret Management**: Store JWT_SECRET in environment variables
- **Token Expiration**: Use reasonable expiration times (24h for this project)
- **Payload Structure**: Include minimal necessary data (userId, email)

```typescript
const token = jwt.sign(
  { userId: user.id, email: user.email },
  jwtSecret,
  { expiresIn: '24h' }
);
```

## Password Security

- **Hashing**: Use bcrypt with salt rounds (10 for this project)
- **Validation**: Minimum 8 characters, proper email format
- **Never Store Plaintext**: Always hash passwords before storage

```typescript
const hashedPassword = await bcrypt.hash(password, 10);
const isPasswordValid = await bcrypt.compare(password, user.password);
```

## Middleware Patterns

- **Protect Middleware**: Verify JWT tokens for authenticated routes
- **Role-based Access**: Check user roles and merchant status
- **Request Extension**: Extend Request type with user/merchant data

```typescript
export interface AuthRequest extends Request {
  user?: { id: number; email: string; };
  merchant?: { id: number; status: 'PENDING' | 'APPROVED' | 'REJECTED' };
}
```

## Authorization Levels

1. **Public**: No authentication required (deal discovery)
2. **User**: Basic authentication required (profile access)
3. **Merchant**: User must have approved merchant status (deal creation)

## Security Best Practices

- **Input Validation**: Use Zod schemas for all inputs
- **Error Messages**: Generic error messages for security (don't reveal user existence)
- **CORS**: Configure CORS for cross-origin requests
- **Environment Variables**: Never commit secrets to version control

## Route Protection Examples

```typescript
// Public route
router.get('/deals', async (req, res) => { /* no auth */ });

// Protected route
router.get('/me', protect, async (req: AuthRequest, res) => { /* user auth */ });

// Merchant-only route
router.post('/deals', protect, isApprovedMerchant, async (req: AuthRequest, res) => { /* merchant auth */ });
```

## Error Handling

- **401 Unauthorized**: Missing or invalid token
- **403 Forbidden**: Valid token but insufficient permissions
- **409 Conflict**: Resource already exists (duplicate email/merchant)
</file>

<file path=".cursor/rules/database-patterns.mdc">
---
globs: prisma/*.prisma,src/lib/prisma.ts
description: Database patterns and Prisma best practices
---

# Database and Prisma Patterns

## Schema Design

- **Enums**: Use for controlled values (UserRole, MerchantStatus, DealCategory)
- **Relationships**: Clear foreign key relationships with proper constraints
- **Indexes**: Performance indexes for frequently queried fields
- **Timestamps**: Always include `createdAt` and `updatedAt` fields

## Prisma Client Usage

```typescript
// Singleton pattern for Prisma client
import { PrismaClient } from '@prisma/client';
const prisma = new PrismaClient();
export default prisma;
```

## Query Patterns

- **Selective Fields**: Use `select` to limit returned fields
- **Include Relations**: Use `include` for related data
- **Transactions**: Use `$transaction` for multi-step operations
- **Error Handling**: Wrap Prisma operations in try-catch blocks

## Common Query Patterns

```typescript
// Find with relations
const deals = await prisma.deal.findMany({
  where: { /* conditions */ },
  include: {
    merchant: {
      select: { id: true, businessName: true, /* other fields */ }
    }
  }
});

// Update with transaction
const [merchant, user] = await prisma.$transaction([
  prisma.merchant.create({ data: merchantData }),
  prisma.user.update({ where: { id }, data: { role: 'MERCHANT' } })
]);
```

## Data Validation

- **Required Fields**: Enforce at schema level with `@id`, `@unique`
- **Optional Fields**: Use `?` for nullable fields
- **Defaults**: Use `@default()` for sensible defaults
- **Constraints**: Use database-level constraints for data integrity

## Performance Optimization

- **Indexes**: Create indexes for frequently queried fields
- **Query Optimization**: Use `select` to limit data transfer
- **Connection Management**: Use singleton Prisma client
- **Error Logging**: Log slow queries for optimization

## Migration Patterns

- **Incremental Changes**: Small, focused migrations
- **Backward Compatibility**: Consider data migration strategies
- **Index Creation**: Add indexes in separate migrations for large tables
</file>

<file path=".cursor/rules/deal-categories.mdc">
---
description: Deal categories and business logic patterns
globs: src/routes/*.ts
---

# Deal Categories and Business Logic

## Category Management

- **Enum Values**: Use predefined enum values from Prisma schema
- **Validation**: Always validate category against allowed values
- **Default Category**: Use 'OTHER' as fallback for unspecified categories

```typescript
const validCategories = [
  'FOOD_AND_BEVERAGE', 'RETAIL', 'ENTERTAINMENT', 'HEALTH_AND_FITNESS',
  'BEAUTY_AND_SPA', 'AUTOMOTIVE', 'TRAVEL', 'EDUCATION', 'TECHNOLOGY',
  'HOME_AND_GARDEN', 'OTHER'
];
```

## Category API Endpoints

- **Categories List**: Provide user-friendly category information
- **Metadata**: Include labels, descriptions, and icons for frontend
- **Versioning**: Track category metadata version for API compatibility

## Deal Validation

- **Time Validation**: Ensure startTime < endTime
- **Required Fields**: Title, description, start time, end time are mandatory
- **Optional Fields**: Image URL, discount values, redemption instructions
- **Merchant Association**: All deals must be associated with approved merchants

## Business Rules

- **Active Deals**: Only show deals where current time is between start and end time
- **Merchant Status**: Only show deals from approved merchants
- **Geolocation**: Optional coordinate filtering with radius validation
- **Search**: Case-insensitive search across title and description

## Performance Considerations

- **Index Usage**: Leverage database indexes for time-based and status filtering
- **Query Optimization**: Filter by merchant status before other operations
- **Caching**: Consider caching category lists and frequently accessed data
</file>

<file path=".cursor/rules/development-workflow.mdc">
---
alwaysApply: true
description: Development workflow and best practices
---

# Development Workflow

## Environment Setup

- **Environment Variables**: Use `.env` file for configuration
- **Required Variables**: `DATABASE_URL`, `JWT_SECRET`, `PORT`
- **Development Server**: Use `npm run dev` with nodemon for auto-reload

## Database Management

- **Migrations**: Use Prisma migrations for schema changes
- **Schema Updates**: Modify [prisma/schema.prisma](mdc:prisma/schema.prisma) and run `npx prisma migrate dev`
- **Client Generation**: Run `npx prisma generate` after schema changes

## Code Organization

- **Route Separation**: Keep routes organized by feature
- **Middleware Reuse**: Create reusable middleware functions
- **Type Safety**: Use TypeScript interfaces for request/response objects
- **Validation**: Use Zod schemas for all input validation

## Testing Considerations

- **API Testing**: Test all endpoints with proper authentication
- **Error Scenarios**: Test validation errors and edge cases
- **Geolocation Testing**: Test with various coordinate combinations
- **Performance Testing**: Monitor query performance and optimization

## Deployment Preparation

- **Build Process**: Use `npm run build` to compile TypeScript
- **Production Start**: Use `npm start` to run compiled JavaScript
- **Environment Configuration**: Ensure production environment variables are set
- **Database Migration**: Run migrations in production environment

## Code Quality

- **Linting**: Use TypeScript strict mode for type safety
- **Error Handling**: Implement comprehensive error handling
- **Logging**: Add appropriate logging for debugging and monitoring
- **Documentation**: Comment complex business logic and algorithms
</file>

<file path=".cursor/rules/error-handling.mdc">
---
globs: src/**/*.ts
description: Error handling and validation patterns
---

# Error Handling and Validation Patterns

## Input Validation with Zod

- **Schema Definition**: Define schemas for all request bodies
- **Runtime Validation**: Parse and validate all inputs
- **Error Messages**: Provide descriptive validation error messages

```typescript
const registerSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(8, { message: "Password must be at least 8 characters long" }),
  name: z.string().optional(),
});

// Usage
const { email, password, name } = registerSchema.parse(req.body);
```

## Error Response Patterns

```typescript
// Validation errors
if (error instanceof z.ZodError) {
  return res.status(400).json({ errors: error.issues });
}

// Business logic errors
if (existingUser) {
  return res.status(409).json({ error: 'Email is already in use' });
}

// Server errors
console.error('Registration error:', error);
res.status(500).json({ error: 'Internal server error' });
```

## Geolocation Validation

- **Coordinate Bounds**: Validate latitude (-90 to 90) and longitude (-180 to 180)
- **Required Pairs**: Both latitude and longitude must be provided together
- **Number Validation**: Ensure coordinates are valid numbers

```typescript
if (lat < -90 || lat > 90) {
  return res.status(400).json({ error: 'Latitude must be between -90 and 90 degrees' });
}
```

## Try-Catch Patterns

- **Async Operations**: Always wrap async operations in try-catch
- **Error Logging**: Log errors with context for debugging
- **Graceful Degradation**: Return appropriate HTTP status codes

```typescript
try {
  const result = await prisma.operation();
  res.status(200).json({ data: result });
} catch (error) {
  console.error('Operation error:', error);
  res.status(500).json({ error: 'Internal server error' });
}
```

## Business Logic Validation

- **Required Fields**: Check for required fields before processing
- **Data Integrity**: Validate business rules (e.g., deal time ranges)
- **Enum Validation**: Check against valid enum values

```typescript
if (!title || !description || !startTime || !endTime) {
  return res.status(400).json({ error: 'Title, description, start time, and end time are required.' });
}
```

## Performance Monitoring

- **Query Timing**: Log slow database queries
- **Performance Metrics**: Track operation duration
- **Optimization Alerts**: Warn about queries taking > 1000ms

```typescript
const startTime = Date.now();
const result = await prisma.query();
const duration = Date.now() - startTime;
if (duration > 1000) {
  console.warn(`[SLOW QUERY] Operation took ${duration}ms`);
}
```
</file>

<file path=".cursor/rules/geolocation-features.mdc">
---
description: Geolocation-specific patterns and utilities
globs: src/routes/deals.public.routes.ts
---

# Geolocation Features and Patterns

## Distance Calculation

- **Haversine Formula**: Use for accurate distance calculations between coordinates
- **Earth Radius**: 6371 km for standard calculations
- **Distance Units**: Always return distances in kilometers

```typescript
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Earth's radius in kilometers
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // Distance in kilometers
}
```

## Coordinate Validation

- **Latitude Range**: -90 to 90 degrees
- **Longitude Range**: -180 to 180 degrees
- **Required Pairs**: Both coordinates must be provided together
- **Number Validation**: Ensure valid numeric values

## Geolocation Query Patterns

- **Radius Filtering**: Filter deals within specified radius
- **Distance Sorting**: Sort results by proximity to user
- **Null Handling**: Handle merchants without coordinates gracefully

## Performance Optimization

- **Database Filtering**: Use database-level filtering for coordinates
- **Index Utilization**: Leverage geospatial indexes for performance
- **Query Optimization**: Filter by status before distance calculations

## Response Formatting

- **Distance Inclusion**: Include calculated distance in response
- **Rounding**: Round distances to 2 decimal places for display
- **Coordinate Precision**: Maintain full precision in database, format for display
</file>

<file path=".cursor/rules/project-structure.mdc">
---
alwaysApply: true
description: Project structure and architecture guide for GeolocationMVPBackend
---

# GeolocationMVPBackend Project Structure

This is a Node.js/TypeScript backend for a geolocation-based deals platform using Express, Prisma, and PostgreSQL.

## Core Architecture

- **Entry Point**: [src/index.ts](mdc:src/index.ts) - Main Express server setup
- **Database**: PostgreSQL with Prisma ORM - Schema defined in [prisma/schema.prisma](mdc:prisma/schema.prisma)
- **Authentication**: JWT-based with bcrypt password hashing
- **API Routes**: Organized by feature in [src/routes/](mdc:src/routes/)

## Key Models

- **User**: Base user accounts with roles (USER, MERCHANT, ADMIN)
- **Merchant**: Business profiles with geolocation data (latitude/longitude)
- **Deal**: Promotional offers with categories, time validity, and merchant association

## Route Organization

- **Auth Routes**: [src/routes/auth.routes.ts](mdc:src/routes/auth.routes.ts) - Registration, login, profile
- **Merchant Routes**: [src/routes/merchant.routes.ts](mdc:src/routes/merchant.routes.ts) - Protected merchant operations
- **Public Deal Routes**: [src/routes/deals.public.routes.ts](mdc:src/routes/deals.public.routes.ts) - Public deal discovery with geolocation

## Middleware

- **Auth Middleware**: [src/middleware/auth.middleware.ts](mdc:src/middleware/auth.middleware.ts) - JWT verification and merchant status checks

## Database Client

- **Prisma Client**: [src/lib/prisma.ts](mdc:src/lib/prisma.ts) - Singleton database connection

## Configuration

- **TypeScript**: [tsconfig.json](mdc:tsconfig.json) - ES2020 target, strict mode enabled
- **Package Management**: [package.json](mdc:package.json) - Express 5.x, Prisma 6.x, Zod validation
- **Development**: [nodemon.json](mdc:nodemon.json) - TypeScript file watching
</file>

<file path=".cursor/rules/typescript-standards.mdc">
---
globs: *.ts,*.tsx
description: TypeScript coding standards and best practices
---

# TypeScript Standards

## Code Style

- **Semicolons**: Always use semicolons at the end of statements
- **Quotes**: Use single quotes for strings, double quotes for JSON properties
- **Indentation**: 2 spaces for indentation
- **Line Length**: Keep lines under 100 characters when possible

## Type Safety

- **Strict Mode**: Always use strict TypeScript configuration
- **Explicit Types**: Define interfaces for request/response objects
- **No Any**: Avoid `any` type - use proper typing or `unknown`
- **Null Safety**: Use optional chaining (`?.`) and nullish coalescing (`??`)

## Interface Patterns

```typescript
// Extend Express Request for custom properties
export interface AuthRequest extends Request {
  user?: { id: number; email: string; };
  merchant?: { id: number; status: 'PENDING' | 'APPROVED' | 'REJECTED' };
}

// Use Zod for runtime validation
const registerSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(8, { message: "Password must be at least 8 characters long" }),
  name: z.string().optional(),
});
```

## Import Organization

1. Node.js built-ins
2. Third-party packages
3. Local imports (relative paths)
4. Type-only imports last

```typescript
import express, { Express, Request, Response } from 'express';
import prisma from './lib/prisma';
import dotenv from 'dotenv';
import cors from 'cors';
```

## Error Handling

- Use try-catch blocks for async operations
- Return appropriate HTTP status codes
- Log errors with context
- Use Zod for input validation with descriptive error messages
</file>

<file path="docker-compose.prod.yml">
version: '3.8'

services:
  app:
    build:
      context: .
      dockerfile: Dockerfile.prod
    ports:
      - "3000:3000"
    environment:
      - NODE_ENV=production
      - DATABASE_URL=postgresql://postgres:${POSTGRES_PASSWORD}@db:5432/geolocationmvp_prod
      - JWT_SECRET=${JWT_SECRET}
      - ALLOWED_ORIGINS=${ALLOWED_ORIGINS}
    depends_on:
      - db
      - redis
    volumes:
      - ./logs:/app/logs
      - ./backups:/app/backups
    restart: unless-stopped
    networks:
      - app-network

  db:
    image: postgres:15-alpine
    environment:
      - POSTGRES_DB=geolocationmvp_prod
      - POSTGRES_USER=postgres
      - POSTGRES_PASSWORD=${POSTGRES_PASSWORD}
    volumes:
      - postgres_data:/var/lib/postgresql/data
      - ./backups:/backups
    ports:
      - "5432:5432"
    restart: unless-stopped
    networks:
      - app-network

  redis:
    image: redis:7-alpine
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data
    restart: unless-stopped
    networks:
      - app-network

  nginx:
    image: nginx:alpine
    ports:
      - "80:80"
      - "443:443"
    volumes:
      - ./nginx.conf:/etc/nginx/nginx.conf
      - ./ssl:/etc/nginx/ssl
    depends_on:
      - app
    restart: unless-stopped
    networks:
      - app-network

volumes:
  postgres_data:
  redis_data:

networks:
  app-network:
    driver: bridge
</file>

<file path="Dockerfile.prod">
# Multi-stage build for production
FROM node:18-alpine AS builder

# Set working directory
WORKDIR /app

# Copy package files
COPY package*.json ./

# Install dependencies
RUN npm ci --only=production && npm cache clean --force

# Copy source code
COPY . .

# Build the application
RUN npm run build

# Production stage
FROM node:18-alpine AS production

# Create app user for security
RUN addgroup -g 1001 -S nodejs && \
    adduser -S nodejs -u 1001

# Set working directory
WORKDIR /app

# Copy built application from builder stage
COPY --from=builder --chown=nodejs:nodejs /app/dist ./dist
COPY --from=builder --chown=nodejs:nodejs /app/node_modules ./node_modules
COPY --from=builder --chown=nodejs:nodejs /app/package*.json ./
COPY --from=builder --chown=nodejs:nodejs /app/prisma ./prisma

# Create directories for logs and backups
RUN mkdir -p logs backups && chown -R nodejs:nodejs logs backups

# Switch to non-root user
USER nodejs

# Expose port
EXPOSE 3000

# Health check
HEALTHCHECK --interval=30s --timeout=3s --start-period=5s --retries=3 \
  CMD node -e "require('http').get('http://localhost:3000/health', (res) => { process.exit(res.statusCode === 200 ? 0 : 1) })"

# Start the application
CMD ["npm", "start"]
</file>

<file path="docs/cities.md">
# Cities & Stores Functionality

## Overview
This feature introduces normalized geographic data so that:
- You can maintain a curated list of US cities (`City` table) with an `active` flag.
- Merchants can have multiple physical locations (`Store` table) each tied to a City.
- Deals can be filtered by city (through the merchant's stores) and cities can be listed for UI pickers.
- Legacy `Merchant.city` string is retained temporarily for backward compatibility but will be phased out.

## Data Model
Prisma models (see `prisma/schema.prisma`):

```prisma
model City {
  id        Int      @id @default(autoincrement())
  name      String
  state     String
  active    Boolean  @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  stores    Store[]
  @@unique([name, state])
  @@index([active, name])
}

model Store {
  id         Int       @id @default(autoincrement())
  merchantId Int
  cityId     Int
  address    String
  latitude   Float?
  longitude  Float?
  active     Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  merchant   Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  city       City      @relation(fields: [cityId], references: [id])

  @@index([merchantId])
  @@index([cityId])
  @@index([active, cityId])
}

model Merchant {
  // ...existing fields...
  city     String?   // deprecated, will be null when using Stores
  stores   Store[]
}
```

### Important Notes
- `City.active` controls which cities show up by default in public listings.
- `Store.active` allows per-location activation/deactivation without disabling the entire merchant.
- We DO NOT duplicate city name/state on Store—always join.

## Seed Data
Seed script: `scripts/seed-cities.ts` (npm script: `npm run seed:cities`).
Installs the curated list you provided:

Active by default:
- Florida: Miami, Orlando, Tampa
- Georgia: Atlanta
- New York: New York City
- Texas: Dallas, Houston, Austin, San Antonio, Fort Worth, El Paso
- Washington: Seattle

Inactive (can be toggled later):
- California: Los Angeles, San Diego, San Jose, San Francisco
- Others: Chicago (IL), Phoenix (AZ), Philadelphia (PA), Columbus (OH), Indianapolis (IN), Charlotte (NC), Denver (CO), Nashville (TN), Boston (MA)

Run after schema/tables exist:
```bash
npm run seed:cities
```

## API Endpoints
All paths prefixed by `/api` (see route mounting in `src/app.ts`).

### List Cities
`GET /api/cities?active=true&q=searchTerm`

Query Params:
- `active=true|false` (default: `true`) – omit to return only active; set neither param to retrieve only active; explicitly pass both active flags using two calls if needed.
- `q` – case-insensitive substring match on name or state.

Response:
```json
{
  "cities": [ {"id":1,"name":"Miami","state":"Florida","active":true,...} ],
  "total": 3
}
```

### Toggle City Active (Admin)
`POST /api/cities/toggle`
Body:
```json
{ "cityId": 12, "active": false }
```
Requires admin auth (middleware `requireAdmin`).

### List Stores in a City
`GET /api/cities/:cityId/stores`
Query:
- `includeInactive=true` (optional) – include inactive stores.

Returns only stores whose merchants are `APPROVED`.

### Merchant Registration (Restricted)

`POST /api/merchants/register`
Now requires a `cityId` referencing an existing ACTIVE city. The previous behavior that auto-created cities from `cityName`/`state` or accepted a free-form legacy `city` string has been disabled for new merchants.

Body (minimum):

```json
{
  "businessName": "Test Coffee",
  "address": "100 Peachtree St",
  "cityId": 4
}
```
If the city is inactive or invalid, the API returns `400`.

An initial Store is always created using the same address/coords supplied.

### Merchant Store Management

`GET /api/merchants/stores` – list stores for authenticated approved merchant.

`POST /api/merchants/stores`
Body:

```json
{
  "address": "123 Main St",
  "cityId": 5,
  "latitude": 40.7128,
  "longitude": -74.0060
}
```
Only an existing ACTIVE `cityId` is accepted. No on-the-fly city creation.

### Deals by City

`GET /api/deals?cityId=5` filters deals to those whose merchant has at least one Store in the given city. Works alongside existing `category`, `search`, and geolocation filters.

## Database Inspection

Once migrations (or manual table creation) succeed, you can verify tables:

### Using Prisma Studio

```bash
npx prisma studio
```
Then navigate to `City` and `Store`.

### Using psql / SQL (example queries)

```sql
SELECT id, name, state, active FROM "City" ORDER BY state, name;
SELECT s.id, m.businessName, c.name AS city, c.state, s.address
FROM "Store" s
JOIN "Merchant" m ON m.id = s."merchantId"
JOIN "City" c ON c.id = s."cityId"
ORDER BY c.state, c.name, m.businessName;
```

### Raw Check for Tables

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_name IN ('City','Store');
```

## Migration Status & Issues

You encountered a failing migration due to an already existing unique index (`User_referralCode_key`). This blocks automatic migration for the new models.

### Why It Happens

- The database has an index that Prisma tries to create again (likely drift between environments or a previous manual change).

### Resolution Options

1. Safe (preferred): Manually drop the duplicate index only if it is truly a duplicate and matches the intended constraint.
   ```sql
   DROP INDEX IF EXISTS "User_referralCode_key"; -- if it's an index
   ALTER TABLE "User" DROP CONSTRAINT IF EXISTS "User_referralCode_key"; -- if it's a constraint
   ```
   Then re-run:
   ```bash
   npx prisma migrate dev --name add_city_and_store_models
   ```
2. Use `prisma migrate resolve` to mark the migration as applied (only if schema truly matches).
3. For dev only: `prisma migrate reset` (drops all data) then re-seed.
4. Temporary workaround (already added): manual table creation via `scripts/manual-create-city-store.ts` then run the seed. This bypasses the migration history; fix properly before production deploy.

### Recommended Path Forward
- Investigate current constraints:
  ```sql
  SELECT indexname FROM pg_indexes WHERE tablename='User';
  ALTER TABLE "User" ADD CONSTRAINT "User_referralCode_key" UNIQUE ("referralCode"); -- only if missing
  ```
- Adjust migration SQL to skip creating what already exists (edit the specific migration file) or drop the duplicate first.
- After fixing drift, run `npx prisma migrate dev` again.

## Backward Compatibility Strategy
| Aspect | Current | Future Plan |
|--------|---------|-------------|
| `Merchant.city` | Optional string | Deprecate after front-end fully uses cities & stores |
| New merchants | Prefer City/Store | Enforce required `cityId` later |
| Deals query | Merchant->Store->City (filter) | Add direct `cityId` index if performance needed |

## Performance Considerations
- Indexes provided: `(active, name)` on City, `(active, cityId)` on Store for fast active-city lookups and deal filtering.
- If deal volume grows, consider a materialized view that maps dealId -> cityIds for faster filtering.

## Testing Recommendations (Pending)
Create tests (see TODO):
1. Seed fixture cities in a test DB and assert `GET /api/cities` returns only active by default.
2. Merchant registration with inactive or missing cityId should fail (400).
3. Adding a store with inactive cityId should fail (400).
4. Deals endpoint with `cityId` returns only deals from merchants having a store in that city.

## Troubleshooting
| Symptom | Cause | Fix |
|---------|-------|-----|
| P2021 table does not exist | Migrations not applied / manual create failed | Run migrations or manual script, then regenerate client |
| Unique index duplicate error | Drift / prior manual change | Drop duplicate index or edit migration to skip |
| City filter returns empty | No merchant stores in that city | Create stores for merchants in that city |
| Cannot create store: invalid cityId | City not seeded | Seed cities or activate appropriate city |
| Cannot create store: city inactive | City.active = false | Toggle city active via admin endpoint |

## Maintenance Checklist
- Remove legacy `Merchant.city` after front-end is updated.
- Add admin CRUD for cities (create/delete) if needed.
- Add bulk activation endpoint if operations require it.
- Monitor query plans for `/api/deals?cityId=` and add composite indexes if necessary.

---
Generated: (keep date in sync) 2025-09-19.
</file>

<file path="docs/merchant-approval.md">
# Merchant Approval Admin Endpoints

These endpoints allow an `ADMIN` user to review and moderate merchant applications.

## Authentication & Authorization

All endpoints require:

- Valid JWT Bearer token (`Authorization: Bearer <token>`)
- Authenticated user role must be `ADMIN`.

If a non-admin attempts access, a `403` is returned.

## List Merchants

`GET /api/admin/merchants?status=PENDING&page=1&pageSize=50`

Query Parameters:

- `status` (optional) One of `PENDING|APPROVED|REJECTED` (default: `PENDING`)
- `page` (optional) 1-based page number (default 1)
- `pageSize` (optional) max 200 (default 50)

Response:

```json
{
  "page": 1,
  "pageSize": 50,
  "total": 1,
  "merchants": [
    {
      "id": 7,
      "businessName": "BizCo",
      "address": "123 Street",
      "description": null,
      "logoUrl": null,
      "status": "PENDING",
      "createdAt": "2025-09-20T10:00:00.000Z",
      "updatedAt": "2025-09-20T10:00:00.000Z",
      "owner": { "id": 14, "email": "merchant@example.com", "name": null, "role": "MERCHANT" },
      "stores": [ { "id": 3, "cityId": 2, "address": "123 Street", "latitude": null, "longitude": null, "active": true } ]
    }
  ]
}
```

## Approve Merchant

`POST /api/admin/merchants/:id/approve`

Idempotent: approving an already approved merchant returns 200 with a message.

Response:

```json
{ "message": "Merchant approved", "merchant": { /* updated merchant object */ } }
```

Emails: A notification is sent to the owner (best-effort) if email exists.

## Reject Merchant

`POST /api/admin/merchants/:id/reject`

Body (optional):

```json
{ "reason": "Incomplete documents" }
```

The `reason` is not persisted (no column yet); it is included in the notification email only. (Add a column if persistent audit trail is desired.)

Response:

```json
{ "message": "Merchant rejected", "merchant": { /* merchant object */ }, "note": "Reason not stored (no column) - include in email only." }
```

## Notes / Future Enhancements

- Add `rejectionReason` & `approvedAt` / `rejectedAt` timestamp columns if audit history is required.
- Add filtering by `businessName` / `ownerEmail` query params.
- Add activity log entries on status transitions.
- Emit metrics for approvals/rejections.
</file>

<file path="jest.config.ts">
import type { Config } from 'jest';

const config: Config = {
  preset: 'ts-jest',
  testEnvironment: 'node',
  testMatch: ['**/tests/**/*.test.ts'],
  moduleFileExtensions: ['ts', 'js', 'json'],
  setupFilesAfterEnv: ['<rootDir>/tests/setup.ts'],
  verbose: false,
  maxWorkers: 1,
};

export default config;
</file>

<file path="nodemon.json">
{
    "watch": ["src"],
    "ext": "ts",
    "exec": "ts-node ./src/index.ts"
  }
</file>

<file path="prisma/migrations/20250719140239_init/migration.sql">
-- CreateTable
CREATE TABLE "User" (
    "id" SERIAL NOT NULL,
    "email" TEXT NOT NULL,
    "name" TEXT,
    "password" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "User_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "User_email_key" ON "User"("email");
</file>

<file path="prisma/migrations/20250807075826_add_merchant_deal_approval_flow/migration.sql">
-- CreateEnum
CREATE TYPE "UserRole" AS ENUM ('USER', 'MERCHANT', 'ADMIN');

-- CreateEnum
CREATE TYPE "MerchantStatus" AS ENUM ('PENDING', 'APPROVED', 'REJECTED');

-- AlterTable
ALTER TABLE "User" ADD COLUMN     "role" "UserRole" NOT NULL DEFAULT 'USER';

-- CreateTable
CREATE TABLE "Merchant" (
    "id" SERIAL NOT NULL,
    "businessName" TEXT NOT NULL,
    "address" TEXT NOT NULL,
    "description" TEXT,
    "logoUrl" TEXT,
    "status" "MerchantStatus" NOT NULL DEFAULT 'PENDING',
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "ownerId" INTEGER NOT NULL,

    CONSTRAINT "Merchant_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Deal" (
    "id" SERIAL NOT NULL,
    "title" TEXT NOT NULL,
    "description" TEXT NOT NULL,
    "imageUrl" TEXT,
    "discountPercentage" INTEGER,
    "discountAmount" DOUBLE PRECISION,
    "startTime" TIMESTAMP(3) NOT NULL,
    "endTime" TIMESTAMP(3) NOT NULL,
    "redemptionInstructions" TEXT NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,
    "merchantId" INTEGER NOT NULL,

    CONSTRAINT "Deal_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "Merchant_ownerId_key" ON "Merchant"("ownerId");

-- AddForeignKey
ALTER TABLE "Merchant" ADD CONSTRAINT "Merchant_ownerId_fkey" FOREIGN KEY ("ownerId") REFERENCES "User"("id") ON DELETE RESTRICT ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Deal" ADD CONSTRAINT "Deal_merchantId_fkey" FOREIGN KEY ("merchantId") REFERENCES "Merchant"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250826180232_add_merchant_geolocation/migration.sql">
-- AlterTable
ALTER TABLE "Merchant" ADD COLUMN     "latitude" DOUBLE PRECISION,
ADD COLUMN     "longitude" DOUBLE PRECISION;
</file>

<file path="prisma/migrations/20250826180807_add_deal_categories/migration.sql">
-- CreateEnum
CREATE TYPE "DealCategory" AS ENUM ('FOOD_AND_BEVERAGE', 'RETAIL', 'ENTERTAINMENT', 'HEALTH_AND_FITNESS', 'BEAUTY_AND_SPA', 'AUTOMOTIVE', 'TRAVEL', 'EDUCATION', 'TECHNOLOGY', 'HOME_AND_GARDEN', 'OTHER');

-- AlterTable
ALTER TABLE "Deal" ADD COLUMN     "category" "DealCategory" NOT NULL DEFAULT 'OTHER';
</file>

<file path="prisma/migrations/20250826190000_add_performance_indexes/migration.sql">
-- Add performance indexes for GET /api/deals endpoint
-- This migration adds indexes to optimize query performance with multiple filters

-- Composite index for the most common query pattern: active deals from approved merchants
-- This covers: startTime, endTime, merchant.status, and createdAt for sorting
CREATE INDEX "idx_deals_active_approved_created" ON "Deal" ("startTime", "endTime", "createdAt" DESC);

-- Index for category filtering (often used with other filters)
CREATE INDEX "idx_deals_category" ON "Deal" ("category");

-- Composite index for category + active deals
CREATE INDEX "idx_deals_category_active" ON "Deal" ("category", "startTime", "endTime");

-- Full-text search indexes for title and description
-- Using GIN indexes for better performance with ILIKE queries
CREATE INDEX "idx_deals_title_gin" ON "Deal" USING GIN (to_tsvector('english', "title"));
CREATE INDEX "idx_deals_description_gin" ON "Deal" USING GIN (to_tsvector('english', "description"));

-- Index for merchant status (used in JOIN condition)
CREATE INDEX "idx_merchant_status" ON "Merchant" ("status");

-- Composite index for merchant status + coordinates (for geospatial queries)
CREATE INDEX "idx_merchant_status_coordinates" ON "Merchant" ("status", "latitude", "longitude");

-- Index for merchant ID (used in foreign key relationship)
CREATE INDEX "idx_deals_merchant_id" ON "Deal" ("merchantId");

-- Composite index for the most complex query: category + active + merchant status
CREATE INDEX "idx_deals_complex_query" ON "Deal" ("category", "startTime", "endTime", "merchantId", "createdAt" DESC);

-- Index for search optimization (trigram indexes for ILIKE queries)
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX "idx_deals_title_trgm" ON "Deal" USING GIN ("title" gin_trgm_ops);
CREATE INDEX "idx_deals_description_trgm" ON "Deal" USING GIN ("description" gin_trgm_ops);

-- Additional optimized indexes for common query patterns
CREATE INDEX "idx_deals_merchant_status_active" ON "Deal" ("merchantId", "startTime", "endTime");
CREATE INDEX "idx_deals_category_merchant" ON "Deal" ("category", "merchantId");
</file>

<file path="prisma/migrations/20250909133522_add_deal_type_and_recurring_days/migration.sql">
-- CreateEnum
CREATE TYPE "DealType" AS ENUM ('STANDARD', 'HAPPY_HOUR', 'RECURRING');

-- DropIndex
DROP INDEX "idx_deals_active_approved_created";

-- DropIndex
DROP INDEX "idx_deals_category";

-- DropIndex
DROP INDEX "idx_deals_category_active";

-- DropIndex
DROP INDEX "idx_deals_category_merchant";

-- DropIndex
DROP INDEX "idx_deals_complex_query";

-- DropIndex
DROP INDEX "idx_deals_description_trgm";

-- DropIndex
DROP INDEX "idx_deals_merchant_id";

-- DropIndex
DROP INDEX "idx_deals_merchant_status_active";

-- DropIndex
DROP INDEX "idx_deals_title_trgm";

-- DropIndex
DROP INDEX "idx_merchant_status";

-- DropIndex
DROP INDEX "idx_merchant_status_coordinates";

-- AlterTable
ALTER TABLE "Deal" ADD COLUMN     "dealType" "DealType" NOT NULL DEFAULT 'STANDARD',
ADD COLUMN     "recurringDays" TEXT;

-- CreateTable
CREATE TABLE "UserDeal" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "dealId" INTEGER NOT NULL,
    "savedAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "UserDeal_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE UNIQUE INDEX "UserDeal_userId_dealId_key" ON "UserDeal"("userId", "dealId");

-- AddForeignKey
ALTER TABLE "UserDeal" ADD CONSTRAINT "UserDeal_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserDeal" ADD CONSTRAINT "UserDeal_dealId_fkey" FOREIGN KEY ("dealId") REFERENCES "Deal"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250911101651_add_user_points_column/migration.sql">
-- AlterTable
ALTER TABLE "User" ADD COLUMN     "points" INTEGER NOT NULL DEFAULT 0;
</file>

<file path="prisma/migrations/20250911103117_add_gamification_and_checkins/migration.sql">
-- CreateEnum
CREATE TYPE "PointEventType" AS ENUM ('SIGNUP', 'FIRST_CHECKIN_DEAL', 'CHECKIN');

-- CreateTable
CREATE TABLE "UserPointEvent" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "dealId" INTEGER,
    "type" "PointEventType" NOT NULL,
    "points" INTEGER NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "UserPointEvent_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "CheckIn" (
    "id" SERIAL NOT NULL,
    "userId" INTEGER NOT NULL,
    "dealId" INTEGER NOT NULL,
    "merchantId" INTEGER NOT NULL,
    "latitude" DOUBLE PRECISION NOT NULL,
    "longitude" DOUBLE PRECISION NOT NULL,
    "distanceMeters" DOUBLE PRECISION NOT NULL,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,

    CONSTRAINT "CheckIn_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "UserPointEvent_userId_type_idx" ON "UserPointEvent"("userId", "type");

-- CreateIndex
CREATE INDEX "UserPointEvent_userId_dealId_idx" ON "UserPointEvent"("userId", "dealId");

-- CreateIndex
CREATE INDEX "CheckIn_userId_dealId_idx" ON "CheckIn"("userId", "dealId");

-- CreateIndex
CREATE INDEX "CheckIn_merchantId_idx" ON "CheckIn"("merchantId");

-- AddForeignKey
ALTER TABLE "UserPointEvent" ADD CONSTRAINT "UserPointEvent_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "UserPointEvent" ADD CONSTRAINT "UserPointEvent_dealId_fkey" FOREIGN KEY ("dealId") REFERENCES "Deal"("id") ON DELETE SET NULL ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CheckIn" ADD CONSTRAINT "CheckIn_userId_fkey" FOREIGN KEY ("userId") REFERENCES "User"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "CheckIn" ADD CONSTRAINT "CheckIn_dealId_fkey" FOREIGN KEY ("dealId") REFERENCES "Deal"("id") ON DELETE CASCADE ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250911120000_add_leaderboard_indexes/migration.sql">
-- Add indexes to support leaderboard queries on UserPointEvent
CREATE INDEX IF NOT EXISTS "UserPointEvent_createdAt_idx" ON "UserPointEvent" ("createdAt");
CREATE INDEX IF NOT EXISTS "UserPointEvent_createdAt_userId_idx" ON "UserPointEvent" ("createdAt","userId");
</file>

<file path="prisma/migrations/20250911123000_add_monthly_points_column/migration.sql">
ALTER TABLE "User" ADD COLUMN "monthlyPoints" INT NOT NULL DEFAULT 0;
</file>

<file path="prisma/migrations/20250911124500_add_covering_index_userpointevent/migration.sql">
-- Composite index to speed up range aggregations and HAVING filters
CREATE INDEX IF NOT EXISTS "UserPointEvent_createdAt_userId_points_idx" ON "UserPointEvent" ("createdAt","userId") INCLUDE ("points");
</file>

<file path="prisma/migrations/20250911130000_add_referral_code/migration.sql">
-- Add referralCode column to User table and unique index
ALTER TABLE "User" ADD COLUMN "referralCode" TEXT;
CREATE UNIQUE INDEX "User_referralCode_key" ON "User"("referralCode") WHERE "referralCode" IS NOT NULL;
</file>

<file path="prisma/migrations/20250911131500_add_user_referrals/migration.sql">
-- Add self-referential referral tracking columns
ALTER TABLE "User" ADD COLUMN "referredByUserId" INTEGER;

-- Index for lookups by referrer
CREATE INDEX "User_referredByUserId_idx" ON "User"("referredByUserId");

-- Add FK constraint (deferred optional)
ALTER TABLE "User" ADD CONSTRAINT "User_referredByUserId_fkey" FOREIGN KEY ("referredByUserId") REFERENCES "User"(id) ON DELETE SET NULL ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/20250911133000_add_user_birthday/migration.sql">
-- Add optional birthday column to User
ALTER TABLE "User" ADD COLUMN "birthday" TIMESTAMP;
-- Index for month/day lookup (expression index could be better, but simple index on birthday helps range scans)
CREATE INDEX IF NOT EXISTS "User_birthday_idx" ON "User"("birthday");
</file>

<file path="prisma/migrations/20250918194506_referral/migration.sql">
/*
  Warnings:

  - A unique constraint covering the columns `[referralCode]` on the table `User` will be added. If there are existing duplicate values, this will fail.

*/
-- DropIndex
DROP INDEX "User_birthday_idx";

-- DropIndex
DROP INDEX "UserPointEvent_createdAt_userId_points_idx";

-- AlterTable
ALTER TABLE "Merchant" ADD COLUMN     "city" TEXT;

-- AlterTable
ALTER TABLE "User" ALTER COLUMN "birthday" SET DATA TYPE TIMESTAMP(3);

-- CreateTable
CREATE TABLE "City" (
    "id" SERIAL NOT NULL,
    "name" TEXT NOT NULL,
    "state" TEXT NOT NULL,
    "active" BOOLEAN NOT NULL DEFAULT false,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "City_pkey" PRIMARY KEY ("id")
);

-- CreateTable
CREATE TABLE "Store" (
    "id" SERIAL NOT NULL,
    "merchantId" INTEGER NOT NULL,
    "cityId" INTEGER NOT NULL,
    "address" TEXT NOT NULL,
    "latitude" DOUBLE PRECISION,
    "longitude" DOUBLE PRECISION,
    "active" BOOLEAN NOT NULL DEFAULT true,
    "createdAt" TIMESTAMP(3) NOT NULL DEFAULT CURRENT_TIMESTAMP,
    "updatedAt" TIMESTAMP(3) NOT NULL,

    CONSTRAINT "Store_pkey" PRIMARY KEY ("id")
);

-- CreateIndex
CREATE INDEX "City_active_name_idx" ON "City"("active", "name");

-- CreateIndex
CREATE UNIQUE INDEX "City_name_state_key" ON "City"("name", "state");

-- CreateIndex
CREATE INDEX "Store_merchantId_idx" ON "Store"("merchantId");

-- CreateIndex
CREATE INDEX "Store_cityId_idx" ON "Store"("cityId");

-- CreateIndex
CREATE INDEX "Store_active_cityId_idx" ON "Store"("active", "cityId");

-- Duplicate of earlier migration's index; skip creating again

-- AddForeignKey
ALTER TABLE "Store" ADD CONSTRAINT "Store_merchantId_fkey" FOREIGN KEY ("merchantId") REFERENCES "Merchant"("id") ON DELETE CASCADE ON UPDATE CASCADE;

-- AddForeignKey
ALTER TABLE "Store" ADD CONSTRAINT "Store_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"("id") ON DELETE RESTRICT ON UPDATE CASCADE;
</file>

<file path="prisma/migrations/migration_lock.toml">
# Please do not edit this file manually
# It should be added in your version-control system (e.g., Git)
provider = "postgresql"
</file>

<file path="scripts/backfill-merchant-stores.ts">
// scripts/backfill-merchant-stores.ts
// Purpose: One-time (idempotent) backfill to create Store rows for any Merchant
// that (a) still has the legacy string `city` populated and (b) has no Store records yet.
//
// Strategy:
// 1. Find merchants where merchant.city IS NOT NULL AND stores count = 0.
// 2. Attempt to resolve the legacy city string against existing City rows by name (case-insensitive)
//    across any state (ambiguous names logged). If multiple matches -> skip & log manual action.
// 3. If no City match found, create a new inactive City with state="UNKNOWN" so data isn't lost.
// 4. Create a Store row with merchant.address, coordinates, resolved cityId.
// 5. Set merchant.city = NULL (so we don't reprocess) within the same transaction.
//
// Safety:
// - Run read-only dry-run mode with DRY_RUN=true to preview operations.
// - Idempotent: merchants processed will have legacy city cleared and thus not selected again.
//
// Environment:
//   DRY_RUN=true (optional) -> no writes, just console output
//
// Exit codes:
//   0 success
//   1 unexpected error

import prisma from '../src/lib/prisma';

interface PendingMerchantInfo {
  id: number;
  businessName: string;
  city: string;
  address: string;
  latitude: number | null;
  longitude: number | null;
}

const DRY_RUN = process.env.DRY_RUN === 'true';

async function main() {
  console.log(`[backfill-stores] Starting backfill. DRY_RUN=${DRY_RUN}`);

  // 1. Pull candidate merchants
  // We can't filter by stores.count directly; fetch merchants with legacy city then check stores length.
  const legacyMerchants = await prisma.merchant.findMany({
    where: { city: { not: null } },
    select: { id: true, businessName: true, city: true, address: true, latitude: true, longitude: true, stores: { select: { id: true } } }
  });

  const candidates: PendingMerchantInfo[] = legacyMerchants
    .filter(m => m.stores.length === 0 && m.city)
    .map(m => ({ id: m.id, businessName: m.businessName, city: m.city!, address: m.address, latitude: m.latitude, longitude: m.longitude }));

  if (candidates.length === 0) {
    console.log('[backfill-stores] No merchants need backfill. Nothing to do.');
    return;
  }

  console.log(`[backfill-stores] Found ${candidates.length} merchants needing store creation.`);

  let createdStores = 0;
  const ambiguous: PendingMerchantInfo[] = [];
  const failures: { merchant: PendingMerchantInfo; error: any }[] = [];

  for (const merchant of candidates) {
    const legacyCityRaw = merchant.city.trim();
    if (!legacyCityRaw) {
      console.log(`[backfill-stores] Merchant ${merchant.id} has empty trimmed city; skipping.`);
      continue;
    }
    // Attempt match case-insensitive by City.name
    // @ts-ignore
    const matches = await prisma.city.findMany({ where: { name: { equals: legacyCityRaw, mode: 'insensitive' } } });
    if (matches.length > 1) {
      console.warn(`[backfill-stores] Ambiguous city name '${legacyCityRaw}' for merchant ${merchant.id}; matches=${matches.map(c => `${c.name},${c.state}`).join('|')}. Skipping.`);
      ambiguous.push(merchant);
      continue;
    }

    let cityId: number | null = null;
    if (matches.length === 1) {
      cityId = matches[0].id;
    } else {
      // No match: create placeholder inactive city with UNKNOWN state
      if (DRY_RUN) {
        console.log(`[backfill-stores] Would create placeholder City '${legacyCityRaw}, UNKNOWN' for merchant ${merchant.id}`);
      } else {
        // @ts-ignore
        const created = await prisma.city.create({ data: { name: legacyCityRaw, state: 'UNKNOWN', active: false } });
        cityId = created.id;
        console.log(`[backfill-stores] Created placeholder City id=${cityId} name='${legacyCityRaw}' state='UNKNOWN'`);
      }
    }

    if (cityId === null && !DRY_RUN) {
      console.warn(`[backfill-stores] Could not resolve city for merchant ${merchant.id}; skipping.`);
      continue;
    }

    try {
      if (DRY_RUN) {
        console.log(`[backfill-stores] Would create Store for merchant ${merchant.id} cityId=${cityId} address='${merchant.address}'`);
        console.log(`[backfill-stores] Would null legacy merchant.city for merchant ${merchant.id}`);
        createdStores++;
      } else {
        await prisma.$transaction(async (tx) => {
          if (cityId === null) throw new Error('cityId unexpectedly null before store create');
          // @ts-ignore
          await tx.store.create({
            data: {
              merchantId: merchant.id,
              cityId,
              address: merchant.address,
              latitude: merchant.latitude,
              longitude: merchant.longitude,
              active: true,
            }
          });
          await tx.merchant.update({ where: { id: merchant.id }, data: { city: null } });
        });
        createdStores++;
        console.log(`[backfill-stores] Created store + cleared legacy city for merchant ${merchant.id}`);
      }
    } catch (err) {
      console.error(`[backfill-stores] Failed merchant ${merchant.id}`, err);
      failures.push({ merchant, error: err });
    }
  }

  console.log(`[backfill-stores] Summary: createdStores=${createdStores} ambiguous=${ambiguous.length} failures=${failures.length}`);
  if (ambiguous.length) {
    console.log('[backfill-stores] Ambiguous merchants:');
    ambiguous.forEach(m => console.log(`  merchantId=${m.id} business='${m.businessName}' city='${m.city}'`));
  }
  if (failures.length) {
    console.log('[backfill-stores] Failures:');
    failures.forEach(f => console.log(`  merchantId=${f.merchant.id} error=${f.error?.message || f.error}`));
    process.exitCode = 1;
  }
  console.log('[backfill-stores] Completed.');
}

main().catch(e => {
  console.error('[backfill-stores] Unhandled error', e);
  process.exit(1);
}).finally(async () => {
  await prisma.$disconnect();
});
</file>

<file path="scripts/backfill-referral-codes.ts">
import prisma from '../src/lib/prisma';

function generateReferralCode(): string {
  const alphabet = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
  let code = '';
  for (let i = 0; i < 8; i++) code += alphabet[Math.floor(Math.random() * alphabet.length)];
  return code;
}

async function getUniqueReferralCode(): Promise<string> {
  for (let attempt = 0; attempt < 10; attempt++) {
    const code = generateReferralCode();
    // @ts-ignore schema may not yet include field during generate
    const existing = await prisma.user.findFirst({ where: { referralCode: code }, select: { id: true } });
    if (!existing) return code;
  }
  throw new Error('Failed to generate unique referral code after 10 attempts');
}

async function main() {
  // @ts-ignore schema pending generate
  const users = await prisma.user.findMany({ where: { OR: [{ referralCode: null }, { referralCode: '' }] }, select: { id: true } });
  console.log(`Found ${users.length} users missing referralCode`);
  for (const u of users) {
    const code = await getUniqueReferralCode();
    // @ts-ignore schema pending generate
    await prisma.user.update({ where: { id: u.id }, data: { referralCode: code } });
    console.log(`Assigned referralCode ${code} to user ${u.id}`);
  }
  console.log('Backfill complete');
}

main().catch(e => { console.error(e); process.exit(1); }).finally(() => prisma.$disconnect());
</file>

<file path="scripts/db-health-check.ts">
import prisma from '../src/lib/prisma';

async function main() {
  console.log('[db-health] Starting connectivity check');
  try {
    const now = await prisma.$queryRawUnsafe<{ now: Date }[]>(`SELECT NOW() as now`);
    console.log('[db-health] DB time:', now[0].now);
  } catch (e: any) {
    console.error('[db-health] FAILED to query NOW():', e.code, e.message);
    if (e.code === 'P1001') {
      console.error('[db-health] Cannot reach DB. Verify DATABASE_URL, network, Neon project status.');
    }
    process.exit(1);
  }

  // Check City / Store table presence via information_schema
  const tables = await prisma.$queryRawUnsafe<{ table_name: string }[]>(
    `SELECT table_name FROM information_schema.tables WHERE table_schema='public' AND table_name IN ('City','Store') ORDER BY table_name;`
  );
  console.log('[db-health] Present tables:', tables.map(t => t.table_name).join(', ') || '(none)');

  if (tables.find(t => t.table_name === 'City')) {
    try {
      // @ts-ignore
      const cityCount = await prisma.city.count();
      console.log('[db-health] City count:', cityCount);
    } catch (e: any) {
      console.warn('[db-health] City model query failed (maybe not generated or table mismatch):', e.code, e.message);
    }
  }

  if (tables.find(t => t.table_name === 'Store')) {
    try {
      // @ts-ignore
      const storeCount = await prisma.store.count();
      console.log('[db-health] Store count:', storeCount);
    } catch (e: any) {
      console.warn('[db-health] Store model query failed:', e.code, e.message);
    }
  }

  console.log('[db-health] Completed');
}

main().catch(e => { console.error('[db-health] Unexpected error', e); process.exit(1); }).finally(() => prisma.$disconnect());
</file>

<file path="scripts/manual-create-city-store.ts">
import prisma from '../src/lib/prisma';

async function tableExists(table: string): Promise<boolean> {
  const rows = await prisma.$queryRawUnsafe<{ exists: boolean }[]>(
    `SELECT EXISTS (
       SELECT 1 FROM information_schema.tables 
       WHERE table_schema = 'public' AND table_name = '${table}'
     ) AS exists`
  );
  return rows?.[0]?.exists ?? false;
}

async function ensureCityTable() {
  if (await tableExists('City')) {
    console.log('City table already exists');
    return;
  }
  await prisma.$executeRawUnsafe(`CREATE TABLE "City" (
    id SERIAL PRIMARY KEY,
    name TEXT NOT NULL,
    state TEXT NOT NULL,
    active BOOLEAN NOT NULL DEFAULT FALSE,
    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW()
  )`);
  await prisma.$executeRawUnsafe(`CREATE UNIQUE INDEX "City_name_state_key" ON "City" (name, state)`);
  await prisma.$executeRawUnsafe(`CREATE INDEX "City_active_name_idx" ON "City" (active, name)`);
  console.log('Created City table and indexes');
}

async function ensureStoreTable() {
  if (await tableExists('Store')) {
    console.log('Store table already exists');
    return;
  }
  await prisma.$executeRawUnsafe(`CREATE TABLE "Store" (
    id SERIAL PRIMARY KEY,
    "merchantId" INTEGER NOT NULL,
    "cityId" INTEGER NOT NULL,
    address TEXT NOT NULL,
    latitude DOUBLE PRECISION NULL,
    longitude DOUBLE PRECISION NULL,
    active BOOLEAN NOT NULL DEFAULT TRUE,
    "createdAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    "updatedAt" TIMESTAMPTZ NOT NULL DEFAULT NOW(),
    CONSTRAINT "Store_merchantId_fkey" FOREIGN KEY ("merchantId") REFERENCES "Merchant"(id) ON DELETE CASCADE,
    CONSTRAINT "Store_cityId_fkey" FOREIGN KEY ("cityId") REFERENCES "City"(id)
  )`);
  await prisma.$executeRawUnsafe(`CREATE INDEX "Store_merchantId_idx" ON "Store" ("merchantId")`);
  await prisma.$executeRawUnsafe(`CREATE INDEX "Store_cityId_idx" ON "Store" ("cityId")`);
  await prisma.$executeRawUnsafe(`CREATE INDEX "Store_active_cityId_idx" ON "Store" (active, "cityId")`);
  console.log('Created Store table and indexes');
}

async function main() {
  await ensureCityTable();
  await ensureStoreTable();
}

main().catch(e => { console.error(e); process.exit(1); }).finally(() => prisma.$disconnect());
</file>

<file path="scripts/seed-cities.ts">
import prisma from '../src/lib/prisma';

async function retry<T>(label: string, fn: () => Promise<T>, attempts = 5, baseDelayMs = 500): Promise<T> {
  let lastErr: any;
  for (let i = 1; i <= attempts; i++) {
    try {
      return await fn();
    } catch (e: any) {
      lastErr = e;
      const wait = baseDelayMs * i * i; // quadratic backoff
      console.warn(`[seed:cities] Attempt ${i}/${attempts} failed for ${label}: ${e.code || e.name} ${e.message}`);
      if (i < attempts) {
        console.info(`[seed:cities] Waiting ${wait}ms before retry...`);
        await new Promise(r => setTimeout(r, wait));
      }
    }
  }
  throw lastErr;
}

const seedCities: Array<{ name: string; state: string; active?: boolean }> = [
  // Florida (active)
  { name: 'Miami', state: 'Florida', active: true },
  { name: 'Orlando', state: 'Florida', active: true },
  { name: 'Tampa', state: 'Florida', active: true },

  // Georgia (Atlanta active)
  { name: 'Atlanta', state: 'Georgia', active: true },

  // New York (NYC active)
  { name: 'New York City', state: 'New York', active: true },

  // Texas (active)
  { name: 'Dallas', state: 'Texas', active: true },
  { name: 'Houston', state: 'Texas', active: true },
  { name: 'Austin', state: 'Texas', active: true },
  { name: 'San Antonio', state: 'Texas', active: true },
  { name: 'Fort Worth', state: 'Texas', active: true },
  { name: 'El Paso', state: 'Texas', active: true },

  // Washington (Seattle active)
  { name: 'Seattle', state: 'Washington', active: true },

  // California (inactive by default)
  { name: 'Los Angeles', state: 'California' },
  { name: 'San Diego', state: 'California' },
  { name: 'San Jose', state: 'California' },
  { name: 'San Francisco', state: 'California' },

  // Others across the US (inactive by default)
  { name: 'Chicago', state: 'Illinois' },
  { name: 'Phoenix', state: 'Arizona' },
  { name: 'Philadelphia', state: 'Pennsylvania' },
  { name: 'Columbus', state: 'Ohio' },
  { name: 'Indianapolis', state: 'Indiana' },
  { name: 'Charlotte', state: 'North Carolina' },
  { name: 'Denver', state: 'Colorado' },
  { name: 'Nashville', state: 'Tennessee' },
  { name: 'Boston', state: 'Massachusetts' },
];

async function main() {
  console.log('[seed:cities] Starting seeding process. Total cities:', seedCities.length);
  for (const c of seedCities) {
    // @ts-ignore
    const existing = await retry('findFirst city', () => prisma.city.findFirst({ where: { name: c.name, state: c.state } }));
    if (existing) {
      if (typeof c.active === 'boolean' && existing.active !== c.active) {
        // @ts-ignore
        await retry('update city active', () => prisma.city.update({ where: { id: existing.id }, data: { active: c.active } }));
        console.log(`[seed:cities] Updated active flag for ${c.name}, ${c.state} -> ${c.active}`);
      }
      continue;
    }
    // @ts-ignore
    await retry('create city', () => prisma.city.create({ data: { name: c.name, state: c.state, active: !!c.active } }));
    console.log(`[seed:cities] Created city ${c.name}, ${c.state} (active=${!!c.active})`);
  }
  console.log('[seed:cities] Completed successfully.');
}

main().catch(e => {
  console.error('[seed:cities] FAILED:', e);
  if (e.code === 'P1001') {
    console.error('[seed:cities] Prisma could not reach the database. Check NETWORK, DATABASE_URL, Neon project status, or IP allow-list.');
  }
  process.exit(1);
}).finally(() => prisma.$disconnect());
</file>

<file path="src/jobs/dailyBirthday.ts">
// src/jobs/dailyBirthday.ts
// Sends a simple birthday greeting email to users whose birthday (month/day) is today (UTC).
// Assumes User.birthday is stored as a Date (timestamp). Year component is ignored for matching.
// Scheduling: run once shortly after startup (next midnight UTC) then every 24h.

import prisma from '../lib/prisma';
import { sendBirthdayEmail } from '../lib/email';

function msUntilNextUtcMidnight(now = new Date()) {
  const y = now.getUTCFullYear();
  const m = now.getUTCMonth();
  const d = now.getUTCDate();
  const next = new Date(Date.UTC(y, m, d + 1, 0, 0, 0, 50)); // +50ms buffer
  return next.getTime() - now.getTime();
}

let timer: NodeJS.Timeout | null = null;

export async function runBirthdayJob(forDate = new Date()) {
  const month = forDate.getUTCMonth() + 1; // 1-12
  const day = forDate.getUTCDate(); // 1-31

  // Use raw query to avoid pulling all users. Extract month/day via SQL.
  // Postgres: EXTRACT(MONTH from birthday) and EXTRACT(DAY from birthday)
  const users: Array<{ id: number; email: string; name: string | null }> = await prisma.$queryRawUnsafe(
    `SELECT id, email, name FROM "User" WHERE birthday IS NOT NULL AND EXTRACT(MONTH FROM birthday) = $1 AND EXTRACT(DAY FROM birthday) = $2`,
    month,
    day
  );

  for (const u of users) {
    // Fire & forget each send (no await sequencing needed)
    sendBirthdayEmail({ to: u.email, name: u.name || undefined }).catch(err =>
      console.error('[email] birthday send error userId=' + u.id, err)
    );
  }
  if (users.length) {
    console.log(`[birthday-job]: queued ${users.length} birthday emails for ${month}-${day}`);
  }
}

export function scheduleDailyBirthdays() {
  if (timer) return; // idempotent
  const schedule = async () => {
    try {
      await runBirthdayJob();
    } catch (e) {
      console.error('[birthday-job]: failed run', e);
    } finally {
      timer = setTimeout(schedule, 24 * 60 * 60 * 1000); // 24h
    }
  };
  timer = setTimeout(schedule, msUntilNextUtcMidnight());
}
</file>

<file path="src/jobs/monthlyReset.ts">
// src/jobs/monthlyReset.ts
// Resets monthlyPoints for all users at the start of each UTC month.
// Also archives the previous month into an optional historical table in future (placeholder).

import prisma from '../lib/prisma';

export async function resetMonthlyPoints() {
  // Single SQL update; could be large but simple. Consider batching if user count huge.
  await prisma.$executeRawUnsafe('UPDATE "User" SET "monthlyPoints" = 0');
}

// Compute ms until next month UTC
function msUntilNextMonthUTC(now = new Date()) {
  const year = now.getUTCFullYear();
  const month = now.getUTCMonth();
  const firstNext = new Date(Date.UTC(year, month + 1, 1, 0, 0, 0, 0));
  return firstNext.getTime() - now.getTime();
}

let timer: NodeJS.Timeout | null = null;

export function scheduleMonthlyReset() {
  if (timer) return; // idempotent
  const schedule = async () => {
    try {
      await resetMonthlyPoints();
      // After running, schedule next month
      timer = setTimeout(schedule, msUntilNextMonthUTC());
    } catch (e) {
      console.error('Monthly points reset failed:', e);
      // Retry in 1 hour if failure
      timer = setTimeout(schedule, 60 * 60 * 1000);
    }
  };
  // Initial delay until next month boundary
  timer = setTimeout(schedule, msUntilNextMonthUTC());
}
</file>

<file path="src/lib/leaderboard/cache.ts">
// Simple in-memory cache for leaderboard top lists.
// Keyed only by period + limit (not user specific) so we can reuse for different callers.

interface CacheEntry<T> {
  value: T;
  expiresAt: number;
}

const store = new Map<string, CacheEntry<any>>();

export function makeKey(parts: Record<string, any>): string {
  return Object.entries(parts).sort().map(([k,v]) => `${k}=${v}`).join('&');
}

export function getCache<T>(key: string): T | null {
  const e = store.get(key);
  if (!e) return null;
  if (Date.now() > e.expiresAt) { store.delete(key); return null; }
  return e.value as T;
}

export function setCache<T>(key: string, value: T, ttlMs: number) {
  store.set(key, { value, expiresAt: Date.now() + ttlMs });
}

export function invalidateLeaderboardCache(granularity?: string) {
  if (!granularity) { store.clear(); return; }
  for (const k of Array.from(store.keys())) {
    if (k.includes(`granularity=${granularity}`)) store.delete(k);
  }
}

export function cacheTtlForGranularity(granularity: string): number {
  const envOverride = process.env.LEADERBOARD_CACHE_TTL_SECONDS;
  if (envOverride) {
    const s = parseInt(envOverride, 10); if (s>0) return s*1000;
  }
  switch (granularity) {
    case 'day': return 30_000;        // 30s
    case 'week': return 120_000;      // 2m
    case 'month': return 300_000;     // 5m
    case 'all-time': return 900_000;  // 15m
    default: return 60_000;           // custom
  }
}
</file>

<file path="src/lib/leaderboard/period.ts">
// src/lib/leaderboard/period.ts
// Utilities to resolve leaderboard periods into concrete UTC time ranges.

export type PeriodGranularity = 'day' | 'week' | 'month' | 'all-time' | 'custom';

export interface PeriodRange {
  granularity: PeriodGranularity;
  start: Date;           // inclusive
  endExclusive: Date;    // exclusive upper bound
  label: string;         // human friendly label (e.g. 'September 2025')
}

function startOfUTC(date: Date) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth(), date.getUTCDate()));
}

function addUTCMonths(date: Date, n: number) {
  return new Date(Date.UTC(date.getUTCFullYear(), date.getUTCMonth() + n, 1));
}

function startOfUTCWeekISO(date: Date) {
  // ISO week starts Monday. Get day (0=Sun..6=Sat)
  const day = date.getUTCDay();
  const diff = (day === 0 ? -6 : 1 - day); // shift so Monday is first
  const monday = new Date(date);
  monday.setUTCDate(date.getUTCDate() + diff);
  return startOfUTC(monday);
}

export interface ResolvePeriodInput {
  period?: string;
  year?: number; // for explicit month lookups
  month?: number; // 1-12
  from?: string; // ISO
  to?: string;   // ISO
  now?: Date;    // test override
}

export function resolvePeriod(input: ResolvePeriodInput): PeriodRange {
  const now = input.now ?? new Date();
  const period = (input.period || 'month').toLowerCase() as PeriodGranularity;

  if (period === 'all-time') {
    return { granularity: 'all-time', start: new Date(0), endExclusive: new Date(now.getTime() + 1000), label: 'All Time' };
  }

  if (period === 'custom') {
    if (!input.from || !input.to) throw new Error('from and to required for custom period');
    const start = new Date(input.from);
    const endExclusive = new Date(input.to);
    if (isNaN(start.getTime()) || isNaN(endExclusive.getTime())) throw new Error('Invalid from/to date');
    if (endExclusive <= start) throw new Error('to must be after from');
    const maxSpanMs = 1000 * 60 * 60 * 24 * 31; // 31 days limit
    if (endExclusive.getTime() - start.getTime() > maxSpanMs) throw new Error('Custom period too long (max 31 days)');
    return { granularity: 'custom', start, endExclusive, label: 'Custom' };
  }

  if (period === 'day') {
    const start = startOfUTC(now);
    const endExclusive = new Date(start.getTime() + 86400000);
    return { granularity: 'day', start, endExclusive, label: start.toISOString().slice(0,10) };
  }

  if (period === 'week') {
    const start = startOfUTCWeekISO(now);
    const endExclusive = new Date(start.getTime() + 7 * 86400000);
    return { granularity: 'week', start, endExclusive, label: 'Week of ' + start.toISOString().slice(0,10) };
  }

  if (period === 'month') {
    let year = input.year ?? now.getUTCFullYear();
    let month = input.month ?? (now.getUTCMonth() + 1);
    if (month < 1 || month > 12) throw new Error('month must be 1-12');
    const start = new Date(Date.UTC(year, month - 1, 1));
    const endExclusive = addUTCMonths(start, 1);
    const label = start.toLocaleString('en-US', { month: 'long', year: 'numeric', timeZone: 'UTC' });
    return { granularity: 'month', start, endExclusive, label };
  }

  throw new Error('Unsupported period');
}
</file>

<file path="src/lib/metrics.ts">
// Lightweight in-memory metrics & health collector
// Provides: metricsMiddleware, metricsCollector
// NOTE: In production consider Prometheus or a proper time-series store.

import { Request, Response, NextFunction } from 'express';

interface RequestMetric {
  method: string;
  route: string;
  status: number;
  durationMs: number;
  timestamp: number;
}

class MetricsCollector {
  private startTime = Date.now();
  private requestCount = 0;
  private errorCount = 0;
  private recentRequests: RequestMetric[] = [];
  private responseTimeBuckets: Record<string, number> = {
    '<100ms': 0,
    '100-300ms': 0,
    '300-1000ms': 0,
    '>1000ms': 0,
  };

  incrementRequest() {
    this.requestCount += 1;
  }

  incrementError() {
    this.errorCount += 1;
  }

  recordRequest(metric: RequestMetric) {
    this.recentRequests.push(metric);
    if (this.recentRequests.length > 100) {
      this.recentRequests.shift();
    }
    // Bucket
    if (metric.durationMs < 100) this.responseTimeBuckets['<100ms'] += 1;
    else if (metric.durationMs < 300) this.responseTimeBuckets['100-300ms'] += 1;
    else if (metric.durationMs < 1000) this.responseTimeBuckets['300-1000ms'] += 1;
    else this.responseTimeBuckets['>1000ms'] += 1;
  }

  getMetrics() {
    const uptimeSeconds = Math.round((Date.now() - this.startTime) / 1000);
    return {
      uptimeSeconds,
      requestCount: this.requestCount,
      errorCount: this.errorCount,
      errorRate: this.requestCount ? this.errorCount / this.requestCount : 0,
      responseTimeBuckets: { ...this.responseTimeBuckets },
      recentRequests: [...this.recentRequests],
      timestamp: new Date().toISOString(),
    };
  }

  getHealthStatus() {
    const metrics = this.getMetrics();
    const healthy = metrics.errorRate < 0.2; // arbitrary threshold
    return {
      status: healthy ? 'healthy' : 'degraded',
      timestamp: metrics.timestamp,
      uptimeSeconds: metrics.uptimeSeconds,
      requestCount: metrics.requestCount,
      errorCount: metrics.errorCount,
      errorRate: metrics.errorRate,
    };
  }

  resetMetrics() {
    this.requestCount = 0;
    this.errorCount = 0;
    this.recentRequests = [];
    this.responseTimeBuckets = { '<100ms': 0, '100-300ms': 0, '300-1000ms': 0, '>1000ms': 0 };
    this.startTime = Date.now();
  }
}

export const metricsCollector = new MetricsCollector();

export function metricsMiddleware(req: Request, res: Response, next: NextFunction) {
  const start = Date.now();
  metricsCollector.incrementRequest();

  res.on('finish', () => {
    const duration = Date.now() - start;
    const metric: RequestMetric = {
      method: req.method,
      route: req.route?.path || req.path,
      status: res.statusCode,
      durationMs: duration,
      timestamp: Date.now(),
    };
    metricsCollector.recordRequest(metric);
    if (res.statusCode >= 500) metricsCollector.incrementError();
  });

  res.on('error', () => metricsCollector.incrementError());
  next();
}

export default metricsCollector;
</file>

<file path="src/lib/points.ts">
// src/lib/points.ts
// Centralized helpers for gamification point configuration & awarding logic.
// Keeps environment variable parsing in one place so routes stay lean.

// NOTE: All numeric env vars gracefully fallback to sensible defaults if
// not provided or invalid (<=0 or NaN).

function parsePositiveInt(envVal: string | undefined, fallback: number): number {
  if (!envVal) return fallback;
  const n = parseInt(envVal, 10);
  if (isNaN(n) || n <= 0) return fallback;
  return n;
}

export function getPointConfig() {
  return {
    signupPoints: parsePositiveInt(process.env.SIGNUP_POINTS, 50),
    checkInPoints: parsePositiveInt(process.env.CHECKIN_POINTS, 10),
    firstCheckInBonus: parsePositiveInt(process.env.FIRST_CHECKIN_BONUS_POINTS, 25),
    checkInRadiusMeters: parsePositiveInt(process.env.CHECKIN_RADIUS_METERS, 100),
  } as const;
}

export type PointConfig = ReturnType<typeof getPointConfig>;

// Small utility so routes can lazily grab a fresh snapshot (in case envs change between deploys)
export const pointsConfig = getPointConfig();

// If we ever add more complex, feature-flag driven logic (tiers, streaks, etc.)
// we can expand with strategy objects here without changing route handlers.
</file>

<file path="src/lib/prisma.ts">
// src/lib/prisma.ts
import { PrismaClient } from '@prisma/client';

const prisma = new PrismaClient();

export default prisma;
</file>

<file path="src/middleware/production.middleware.ts">
import { Request, Response, NextFunction } from 'express';
import compression from 'compression';
import morgan from 'morgan';
import rateLimit from 'express-rate-limit';
import logger from '../lib/logging/logger';
import { metricsMiddleware } from '../lib/metrics';

// Compression middleware
export const compressionMiddleware = compression({
  level: 6, // Compression level (1-9)
  threshold: 1024, // Only compress responses larger than 1KB
  filter: (req: Request, res: Response) => {
    // Don't compress if the request includes a no-transform directive
    if (req.headers['cache-control'] && req.headers['cache-control'].includes('no-transform')) {
      return false;
    }
    return compression.filter(req, res);
  },
});

// HTTP request logging middleware
export const requestLoggingMiddleware = morgan('combined', {
  stream: {
    write: (message: string) => {
      logger.http(message.trim());
    },
  },
  skip: (req: Request) => {
    // Skip logging for health checks to reduce noise
    return req.url === '/health' || req.url === '/ready' || req.url === '/live';
  },
});

// Production-specific rate limiting
export const productionRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  limit: 100, // Reduced limit for production
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many requests from this IP, please try again later.',
  },
  skip: (req: Request) => {
    // Skip rate limiting for health checks
    return req.url === '/health' || req.url === '/ready' || req.url === '/live';
  },
});

// Strict rate limiting for auth endpoints
export const authRateLimit = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  limit: 5, // Very strict limit for auth endpoints
  standardHeaders: true,
  legacyHeaders: false,
  message: {
    error: 'Too many authentication attempts, please try again later.',
  },
});

// Security headers middleware
export const securityHeadersMiddleware = (req: Request, res: Response, next: NextFunction) => {
  // Remove X-Powered-By header
  res.removeHeader('X-Powered-By');
  
  // Add security headers
  res.setHeader('X-Content-Type-Options', 'nosniff');
  res.setHeader('X-Frame-Options', 'DENY');
  res.setHeader('X-XSS-Protection', '1; mode=block');
  res.setHeader('Referrer-Policy', 'strict-origin-when-cross-origin');
  
  // Add cache control for API responses
  if (req.url.startsWith('/api/')) {
    res.setHeader('Cache-Control', 'no-cache, no-store, must-revalidate');
    res.setHeader('Pragma', 'no-cache');
    res.setHeader('Expires', '0');
  }
  
  next();
};

// Error handling middleware for production
export const productionErrorHandler = (
  error: Error,
  req: Request,
  res: Response,
  next: NextFunction
) => {
  // Log the error
  logger.error('Unhandled error:', {
    error: error.message,
    stack: error.stack,
    url: req.url,
    method: req.method,
    ip: req.ip,
    userAgent: req.get('User-Agent'),
  });
  
  // Don't leak error details in production
  if (process.env.NODE_ENV === 'production') {
    res.status(500).json({
      error: 'Internal server error',
      timestamp: new Date().toISOString(),
    });
  } else {
    // In development, show full error details
    res.status(500).json({
      error: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString(),
    });
  }
};

// Request timeout middleware
export const requestTimeoutMiddleware = (timeoutMs: number = 30000) => {
  return (req: Request, res: Response, next: NextFunction) => {
    const timeout = setTimeout(() => {
      if (!res.headersSent) {
        logger.warn(`Request timeout: ${req.method} ${req.url}`);
        res.status(408).json({
          error: 'Request timeout',
          timestamp: new Date().toISOString(),
        });
      }
    }, timeoutMs);
    
    // Clear timeout when response is sent
    res.on('finish', () => clearTimeout(timeout));
    res.on('close', () => clearTimeout(timeout));
    
    next();
  };
};

// CORS configuration for production
export const productionCorsOptions = {
  origin: (origin: string | undefined, callback: (err: Error | null, allow?: boolean) => void) => {
    // Allow requests with no origin (mobile apps, Postman, etc.)
    if (!origin) return callback(null, true);
    
    const allowedOrigins = process.env.ALLOWED_ORIGINS?.split(',') || [];
    
    if (allowedOrigins.includes(origin)) {
      callback(null, true);
    } else {
      logger.warn(`CORS blocked request from origin: ${origin}`);
      callback(new Error('Not allowed by CORS'), false);
    }
  },
  credentials: true,
  optionsSuccessStatus: 200,
  methods: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS'],
  allowedHeaders: ['Content-Type', 'Authorization', 'X-Requested-With'],
};
</file>

<file path="src/routes/cities.routes.ts">
import { Router } from 'express';
import prisma from '../lib/prisma';
import { protect, requireAdmin, AuthRequest } from '../middleware/auth.middleware';

const router = Router();

// GET /api/cities
// Optional query: active=true|false (default true), q=search by name/state
router.get('/cities', async (req, res) => {
  try {
    const { active = 'true', q } = req.query as Record<string, string>;
    const filter: any = {};
    if (active === 'true') filter.active = true;
    if (active === 'false') filter.active = false;
    if (q) {
      filter.OR = [
        { name: { contains: q, mode: 'insensitive' } },
        { state: { contains: q, mode: 'insensitive' } },
      ];
    }
  // @ts-ignore - available after Prisma generate
  const cities = await prisma.city.findMany({ where: filter, orderBy: [{ active: 'desc' }, { state: 'asc' }, { name: 'asc' }] });
    res.status(200).json({ cities, total: cities.length });
  } catch (e) {
    console.error('Cities list failed', e);
    res.status(500).json({ error: 'Failed to fetch cities' });
  }
});

// POST /api/cities/toggle
// Body: { cityId: number, active: boolean }
router.post('/cities/toggle', protect, requireAdmin, async (req: AuthRequest, res) => {
  try {
    const { cityId, active } = req.body || {};
    if (!cityId || typeof active !== 'boolean') {
      return res.status(400).json({ error: 'cityId (number) and active (boolean) are required' });
    }
  // @ts-ignore - available after Prisma generate
  const updated = await prisma.city.update({ where: { id: Number(cityId) }, data: { active } });
    res.status(200).json({ message: 'City updated', city: updated });
  } catch (e) {
    console.error('City toggle failed', e);
    res.status(500).json({ error: 'Failed to update city' });
  }
});

export default router;

// GET /api/cities/:cityId/stores
// Returns stores in a city, only for approved merchants and active stores by default
router.get('/cities/:cityId/stores', async (req, res) => {
  try {
    const cityId = Number(req.params.cityId);
    const { includeInactive } = req.query as Record<string, string>;
    if (!Number.isFinite(cityId)) return res.status(400).json({ error: 'Invalid cityId' });

    const where: any = { cityId };
    if (includeInactive !== 'true') where.active = true;

    // @ts-ignore - Store model available after Prisma generate
    const stores = await prisma.store.findMany({
      where,
      include: {
        merchant: {
          select: {
            id: true,
            businessName: true,
            status: true,
            logoUrl: true,
          }
        },
        city: true,
      },
      orderBy: [{ active: 'desc' }, { id: 'asc' }]
    });

    // filter to approved merchants
    const filtered = stores.filter((s: any) => s.merchant?.status === 'APPROVED');
    res.status(200).json({ cityId, total: filtered.length, stores: filtered });
  } catch (e) {
    console.error('City stores list failed', e);
    res.status(500).json({ error: 'Failed to fetch stores' });
  }
});
</file>

<file path="src/routes/health.routes.ts">
import { Router, Request, Response } from 'express';
import prisma from '../lib/prisma';
import { metricsCollector } from '../lib/metrics';
import logger from '../lib/logging/logger';

const router = Router();

// Basic health check
router.get('/health', async (req: Request, res: Response) => {
  try {
    // Check database connection
    await prisma.$queryRaw`SELECT 1`;
    
    res.status(200).json({
      status: 'healthy',
      timestamp: new Date().toISOString(),
      service: 'GeolocationMVPBackend',
      version: process.env.npm_package_version || '1.0.0',
    });
  } catch (error) {
    logger.error('Health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: 'Database connection failed',
    });
  }
});

// Detailed health check with metrics
router.get('/health/detailed', async (req: Request, res: Response) => {
  try {
    const startTime = Date.now();
    
    // Check database connection
    await prisma.$queryRaw`SELECT 1`;
    
    const dbResponseTime = Date.now() - startTime;
    const healthStatus = metricsCollector.getHealthStatus();
    
    res.status(200).json({
      ...healthStatus,
      database: {
        status: 'connected',
        responseTime: dbResponseTime,
      },
    });
  } catch (error) {
    logger.error('Detailed health check failed:', error);
    res.status(503).json({
      status: 'unhealthy',
      timestamp: new Date().toISOString(),
      error: 'Health check failed',
      details: error instanceof Error ? error.message : 'Unknown error',
    });
  }
});

// Readiness probe (for Kubernetes)
router.get('/ready', async (req: Request, res: Response) => {
  try {
    // Check if database is ready
    await prisma.$queryRaw`SELECT 1`;
    
    res.status(200).json({
      status: 'ready',
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    logger.error('Readiness check failed:', error);
    res.status(503).json({
      status: 'not ready',
      timestamp: new Date().toISOString(),
      error: 'Database not ready',
    });
  }
});

// Liveness probe (for Kubernetes)
router.get('/live', (req: Request, res: Response) => {
  res.status(200).json({
    status: 'alive',
    timestamp: new Date().toISOString(),
    uptime: process.uptime(),
  });
});

// Metrics endpoint
router.get('/metrics', (req: Request, res: Response) => {
  try {
    const metrics = metricsCollector.getMetrics();
    res.status(200).json({
      metrics,
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    logger.error('Metrics retrieval failed:', error);
    res.status(500).json({
      error: 'Failed to retrieve metrics',
      timestamp: new Date().toISOString(),
    });
  }
});

// Reset metrics endpoint (for testing/admin purposes)
router.post('/metrics/reset', (req: Request, res: Response) => {
  try {
    metricsCollector.resetMetrics();
    logger.info('Metrics reset requested');
    res.status(200).json({
      message: 'Metrics reset successfully',
      timestamp: new Date().toISOString(),
    });
  } catch (error) {
    logger.error('Metrics reset failed:', error);
    res.status(500).json({
      error: 'Failed to reset metrics',
      timestamp: new Date().toISOString(),
    });
  }
});

export default router;
</file>

<file path="src/routes/leaderboard.routes.ts">
import { Router, Response, NextFunction } from 'express';
import { AuthRequest } from '../middleware/auth.middleware';
import { getLeaderboard } from '../lib/leaderboard/leaderboard';

const router = Router();

// Optional auth: attaches user if token valid; silently continues if not.
async function optionalAuth(req: AuthRequest, _res: Response, next: NextFunction) {
  const header = req.headers.authorization;
  if (!header || !header.startsWith('Bearer')) return next();
  const token = header.split(' ')[1];
  const jwtSecret = process.env.JWT_SECRET;
  if (!jwtSecret) return next();
  try {
    const jwtLib = (await import('jsonwebtoken')).default;
    const decoded: any = jwtLib.verify(token, jwtSecret) as { userId: number; email: string };
    req.user = { id: decoded.userId, email: decoded.email };
  } catch { /* ignore */ }
  next();
}

// GET /api/leaderboard
router.get('/', optionalAuth, async (req: AuthRequest, res: Response) => {
  try {
    const { period, limit, includeSelf, year, month, from, to } = req.query;
    const selfUserId = req.user?.id;

    const limitNum = limit ? parseInt(String(limit), 10) : undefined;
    const includeSelfBool = includeSelf === undefined ? true : String(includeSelf).toLowerCase() === 'true';

    const yearNum = year ? parseInt(String(year), 10) : undefined;
    const monthNum = month ? parseInt(String(month), 10) : undefined;

    const result = await getLeaderboard({
      period: period as string | undefined,
      limit: limitNum,
      includeSelf: includeSelfBool,
      selfUserId,
      year: yearNum,
      month: monthNum,
      from: from as string | undefined,
      to: to as string | undefined,
    });

    res.status(200).json(result);
  } catch (e: any) {
    if (/period/i.test(e.message) || /custom period/i.test(e.message) || /limit/i.test(e.message) || /month must be/.test(e.message)) {
      return res.status(400).json({ error: e.message });
    }
    console.error('Leaderboard error:', e);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="src/types/winston-daily-rotate-file.d.ts">
declare module 'winston-daily-rotate-file';
</file>

<file path="tests/admin.merchant.approval.test.ts">
import request from 'supertest';
import app from '../src/app';
import prisma from '../src/lib/prisma';

async function register(email: string, password = 'Password123!') {
  return request(app).post('/api/auth/register').send({ email, password });
}

async function login(email: string, password = 'Password123!') {
  const res = await request(app).post('/api/auth/login').send({ email, password });
  expect(res.status).toBe(200);
  return res.body.token as string;
}

describe('Admin Merchant Approval Flow', () => {
  it('admin can list pending merchants and approve one', async () => {
    // Create admin user manually (upgrade role via prisma)
    const adminRes = await register('admin@example.com');
    expect(adminRes.status).toBe(201);
    await prisma.user.update({ where: { id: adminRes.body.user.id }, data: { role: 'ADMIN' } });

    // Create regular user & merchant application
    const userRes = await register('merchantuser@example.com');
    expect(userRes.status).toBe(201);
    const userToken = await login('merchantuser@example.com');
    // Need an active city for registration
    const city = await prisma.city.create({ data: { name: 'TestCity', state: 'TS', active: true } });
    const regMerchantRes = await request(app)
      .post('/api/merchants/register')
      .set('Authorization', `Bearer ${userToken}`)
      .send({ businessName: 'BizCo', address: '123 Street', cityId: city.id });
    expect(regMerchantRes.status).toBe(201);
    const merchantId = regMerchantRes.body.merchant.id;
    expect(regMerchantRes.body.merchant.status).toBe('PENDING');

    const adminToken = await login('admin@example.com');

    // List pending merchants
    const listRes = await request(app)
      .get('/api/admin/merchants?status=PENDING')
      .set('Authorization', `Bearer ${adminToken}`);
    expect(listRes.status).toBe(200);
    expect(listRes.body.merchants.find((m: any) => m.id === merchantId)).toBeTruthy();

    // Approve merchant
    const approveRes = await request(app)
      .post(`/api/admin/merchants/${merchantId}/approve`)
      .set('Authorization', `Bearer ${adminToken}`);
    expect(approveRes.status).toBe(200);
    expect(approveRes.body.merchant.status).toBe('APPROVED');

    // Ensure merchant cannot be approved again (idempotent)
    const approveAgain = await request(app)
      .post(`/api/admin/merchants/${merchantId}/approve`)
      .set('Authorization', `Bearer ${adminToken}`);
    expect(approveAgain.status).toBe(200);
    expect(approveAgain.body.message).toMatch(/already approved/i);
  });

  it('admin can reject merchant', async () => {
    const adminRes = await register('admin2@example.com');
    await prisma.user.update({ where: { id: adminRes.body.user.id }, data: { role: 'ADMIN' } });
    const adminToken = await login('admin2@example.com');

    const userRes = await register('merchantreject@example.com');
    const userToken = await login('merchantreject@example.com');
    const city = await prisma.city.create({ data: { name: 'RejectCity', state: 'RC', active: true } });
    const reg = await request(app)
      .post('/api/merchants/register')
      .set('Authorization', `Bearer ${userToken}`)
      .send({ businessName: 'RejectCo', address: '321 Ave', cityId: city.id });
    expect(reg.status).toBe(201);
    const merchantId = reg.body.merchant.id;

    const rejectRes = await request(app)
      .post(`/api/admin/merchants/${merchantId}/reject`)
      .set('Authorization', `Bearer ${adminToken}`)
      .send({ reason: 'Incomplete documents' });
    expect(rejectRes.status).toBe(200);
    expect(rejectRes.body.merchant.status).toBe('REJECTED');
  });
});
</file>

<file path="tests/checkin.points.test.ts">
import request from 'supertest';
import app from '../src/app';
import prisma from '../src/lib/prisma';
import jwt from 'jsonwebtoken';
import { getPointConfig } from '../src/lib/points';

// Helper to create a user via API
async function register(email: string) {
  const res = await request(app)
    .post('/api/auth/register')
    .send({ email, password: 'Password123!', name: 'Test User' });
  expect(res.status).toBe(201);
  return res.body.user;
}

// Create merchant + deal directly via prisma (faster than hitting endpoints)
async function createApprovedMerchantWithDeal(ownerUserId: number) {
  const merchant = await prisma.merchant.create({
    data: {
      businessName: 'Test Merchant',
      address: '123 Test St',
      status: 'APPROVED',
      ownerId: ownerUserId,
      latitude: 40.0,
      longitude: -74.0
    }
  });
  const now = new Date();
  const later = new Date(now.getTime() + 60 * 60 * 1000);
  const deal = await prisma.deal.create({
    data: {
      title: 'Test Deal',
      description: 'Desc',
      startTime: now,
      endTime: later,
      redemptionInstructions: 'Show code',
      merchantId: merchant.id
    }
  });
  return { merchant, deal };
}

function signToken(user: { id: number; email: string }) {
  const secret = process.env.JWT_SECRET!;
  return jwt.sign({ userId: user.id, email: user.email }, secret, { expiresIn: '1h' });
}

describe('Check-in & Points Integration', () => {
  const cfg = getPointConfig();

  test('Signup awards signup points and logs SIGNUP event', async () => {
    const user = await register('signup+1@example.com');
    expect(user.points).toBe(cfg.signupPoints);

    const events = await prisma.userPointEvent.findMany({ where: { userId: user.id } });
    expect(events).toHaveLength(1);
    expect(events[0].type).toBe('SIGNUP');
    expect(events[0].points).toBe(cfg.signupPoints);
  });

  test('First check-in awards base + first bonus and logs two events', async () => {
    const user = await register('checkin+1@example.com');
    const { deal } = await createApprovedMerchantWithDeal(user.id);
    const token = signToken(user);

    const res = await request(app)
      .post('/api/users/check-in')
      .set('Authorization', `Bearer ${token}`)
      .send({ dealId: deal.id, latitude: 40.0005, longitude: -74.0005 });

    expect(res.status).toBe(200);
    expect(res.body.pointsAwarded).toBe(cfg.checkInPoints + cfg.firstCheckInBonus);
    expect(res.body.firstCheckIn).toBe(true);

    const dbUser = await prisma.user.findUnique({ where: { id: user.id } });
    expect(dbUser?.points).toBe(cfg.signupPoints + cfg.checkInPoints + cfg.firstCheckInBonus);

    const events = await prisma.userPointEvent.findMany({ where: { userId: user.id }, orderBy: { id: 'asc' } });
    expect(events.map(e => e.type)).toEqual(['SIGNUP', 'FIRST_CHECKIN_DEAL', 'CHECKIN']);
  });

  test('Second check-in on same deal only awards base points', async () => {
    const user = await register('checkin+2@example.com');
    const { deal } = await createApprovedMerchantWithDeal(user.id);
    const token = signToken(user);

    const first = await request(app)
      .post('/api/users/check-in')
      .set('Authorization', `Bearer ${token}`)
      .send({ dealId: deal.id, latitude: 40.0, longitude: -74.0 });
    expect(first.status).toBe(200);

    const second = await request(app)
      .post('/api/users/check-in')
      .set('Authorization', `Bearer ${token}`)
      .send({ dealId: deal.id, latitude: 40.0, longitude: -74.0 });

    expect(second.status).toBe(200);
    expect(second.body.pointsAwarded).toBe(cfg.checkInPoints); // no bonus
    expect(second.body.firstCheckIn).toBe(false);

    const events = await prisma.userPointEvent.findMany({ where: { userId: user.id }, orderBy: { id: 'asc' } });
    // SIGNUP + (bonus+base) + base
    expect(events.map(e => e.type)).toEqual(['SIGNUP', 'FIRST_CHECKIN_DEAL', 'CHECKIN', 'CHECKIN']);
  });

  test('Check-in outside radius returns withinRange=false and awards 0 points', async () => {
    const user = await register('checkin+3@example.com');
    const { deal } = await createApprovedMerchantWithDeal(user.id);
    const token = signToken(user);

    const res = await request(app)
      .post('/api/users/check-in')
      .set('Authorization', `Bearer ${token}`)
      // Far away (~15km)
      .send({ dealId: deal.id, latitude: 40.2, longitude: -74.2 });

    expect(res.status).toBe(200);
    expect(res.body.withinRange).toBe(false);
    expect(res.body.pointsAwarded).toBe(0);

    const events = await prisma.userPointEvent.findMany({ where: { userId: user.id } });
    // Only signup event
    expect(events).toHaveLength(1);
  });
});
</file>

<file path="tests/leaderboard.test.ts">
// Leaderboard tests intentionally omitted per request.
</file>

<file path="tests/referral.success.email.test.ts">
import request from 'supertest';
import app from '../src/app';
import prisma from '../src/lib/prisma';

jest.mock('../src/lib/email', () => {
  const original = jest.requireActual('../src/lib/email');
  return {
    ...original,
    sendEmail: jest.fn().mockResolvedValue(undefined),
  };
});

import { sendEmail } from '../src/lib/email';

async function register(email: string, referralCode?: string) {
  const payload: any = { email, password: 'Password123!' };
  if (referralCode) payload.referralCode = referralCode;
  const res = await request(app).post('/api/auth/register').send(payload);
  return res;
}

describe('Referral Success Email', () => {
  it('sends a referral success email to referrer when code used', async () => {
    const referrerRes = await register('refsuccessreferrer@example.com');
    expect(referrerRes.status).toBe(201);
    const referrerId = referrerRes.body.user.id;
    const referrer = await prisma.user.findUnique({ where: { id: referrerId } });
    // @ts-ignore
    const code = referrer?.referralCode as string;
    expect(code).toBeDefined();

    const referredRes = await register('refsuccessreferred@example.com', code);
    expect(referredRes.status).toBe(201);

    // find a call with tag 'referral-success' and to = referrer email
    const calls = (sendEmail as jest.Mock).mock.calls;
    const match = calls.find((c: any[]) => c[0]?.tags?.includes('referral-success'));
    expect(match).toBeTruthy();
    expect(match[0].to).toMatchObject({ email: 'refsuccessreferrer@example.com' });
  });
});
</file>

<file path="tests/referral.test.ts">
import request from 'supertest';
import app from '../src/app';
import prisma from '../src/lib/prisma';

describe('Referral Code Generation', () => {
  it('assigns a referralCode during registration', async () => {
    const res = await request(app)
      .post('/api/auth/register')
      .send({ email: 'referral@example.com', password: 'Password123!' });
    expect(res.status).toBe(201);
    const userId = res.body.user.id;
    const user = await prisma.user.findUnique({ where: { id: userId } });
    // @ts-ignore pending prisma generate
    expect(user?.referralCode).toBeDefined();
    // @ts-ignore
    expect((user!.referralCode as string).length).toBe(8);
  });
});
</file>

<file path="tests/referrals.endpoint.test.ts">
import request from 'supertest';
import app from '../src/app';
import prisma from '../src/lib/prisma';

async function register(email: string, referralCode?: string) {
  const payload: any = { email, password: 'Password123!' };
  if (referralCode) payload.referralCode = referralCode;
  const res = await request(app).post('/api/auth/register').send(payload);
  return res;
}

async function login(email: string) {
  const res = await request(app).post('/api/auth/login').send({ email, password: 'Password123!' });
  return res.body.token as string;
}

describe('GET /api/users/referrals', () => {
  it('returns referral count for a user', async () => {
    // Create referrer
    const referrerRes = await register('referrer@example.com');
    expect(referrerRes.status).toBe(201);
    const referrerId = referrerRes.body.user.id;
    const referrer = await prisma.user.findUnique({ where: { id: referrerId } });
    // @ts-ignore
    const code = referrer?.referralCode as string;
    expect(code).toBeDefined();

    // Register two referred users
    await register('referred1@example.com', code);
    await register('referred2@example.com', code);

    const token = await login('referrer@example.com');
    const res = await request(app).get('/api/users/referrals').set('Authorization', `Bearer ${token}`);
    expect(res.status).toBe(200);
    expect(res.body.referralCode).toBe(code);
    expect(res.body.referralCount).toBe(2);
  });
});
</file>

<file path="tests/setup.ts">
/// <reference types="jest" />
import { execSync } from 'child_process';
import prisma from '../src/lib/prisma';
import { resetDatabase } from '../src/app';

// Ensure NODE_ENV=test
process.env.NODE_ENV = 'test';
process.env.JWT_SECRET = process.env.JWT_SECRET || 'test-secret';
process.env.SIGNUP_POINTS = process.env.SIGNUP_POINTS || '50';
process.env.CHECKIN_POINTS = process.env.CHECKIN_POINTS || '10';
process.env.FIRST_CHECKIN_BONUS_POINTS = process.env.FIRST_CHECKIN_BONUS_POINTS || '25';
process.env.CHECKIN_RADIUS_METERS = process.env.CHECKIN_RADIUS_METERS || '200';

beforeAll(async () => {
  // Run prisma migrate deploy to ensure schema is ready for tests
  // (Assumes DATABASE_URL points to a test DB)
  try {
    execSync('npx prisma migrate deploy', { stdio: 'inherit' });
  } catch (e) {
    console.error('Failed to run migrations for tests', e);
    throw e;
  }
  await resetDatabase();
});

afterEach(async () => {
  await resetDatabase();
});

afterAll(async () => {
  await prisma.$disconnect();
});
</file>

<file path="tests/welcome.email.test.ts">
import request from 'supertest';
import app from '../src/app';

// We'll mock sendEmail to capture calls without performing real HTTP requests
jest.mock('../src/lib/email', () => {
  const original = jest.requireActual('../src/lib/email');
  return {
    ...original,
    sendEmail: jest.fn().mockResolvedValue(undefined),
  };
});

import { sendEmail } from '../src/lib/email';

describe('Welcome Email', () => {
  it('sends a welcome email after successful registration', async () => {
    const res = await request(app)
      .post('/api/auth/register')
      .send({ email: 'welcome@test.com', password: 'Password123!' });

    expect(res.status).toBe(201);

    // Assert our mocked sendEmail was called with welcome tag
    expect(sendEmail).toHaveBeenCalled();
    const found = (sendEmail as jest.Mock).mock.calls.find((c) => Array.isArray(c) && c[0]?.tags?.includes('welcome'));
    expect(found).toBeTruthy();
    expect(found[0].to).toMatchObject({ email: 'welcome@test.com' });
  });
});
</file>

<file path=".gitignore">
node_modules
# Keep environment variables out of version control
.env

/generated/prisma
dist
</file>

<file path="prisma/migrations/20250911115350_leaderboard/migration.sql">
-- Drop old covering index if it existed in earlier development iterations
DROP INDEX IF EXISTS "UserPointEvent_createdAt_userId_points_idx";
</file>

<file path="src/lib/logging/logger.ts">
import winston from 'winston';
import DailyRotateFile from 'winston-daily-rotate-file';
import path from 'path';

// Define log levels
const levels = {
  error: 0,
  warn: 1,
  info: 2,
  http: 3,
  debug: 4,
};

// Define colors for each level
const colors = {
  error: 'red',
  warn: 'yellow',
  info: 'green',
  http: 'magenta',
  debug: 'white',
};

// Tell winston that you want to link the colors
winston.addColors(colors);

// Define which transports the logger must use
const transports = [
  // Console transport
  new winston.transports.Console({
    format: winston.format.combine(
      winston.format.timestamp({ format: 'YYYY-MM-DD HH:mm:ss:ms' }),
      winston.format.colorize({ all: true }),
      winston.format.printf(
        (info: winston.Logform.TransformableInfo) => `${info.timestamp} ${info.level}: ${info.message}`
      )
    ),
  }),
  // File transport for errors
  new DailyRotateFile({
    filename: path.join('logs', 'error-%DATE%.log'),
    datePattern: 'YYYY-MM-DD',
    level: 'error',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.json()
    ),
    maxSize: '20m',
    maxFiles: '14d',
  }),
  // File transport for all logs
  new DailyRotateFile({
    filename: path.join('logs', 'combined-%DATE%.log'),
    datePattern: 'YYYY-MM-DD',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.json()
    ),
    maxSize: '20m',
    maxFiles: '30d',
  }),
];

// Create the logger
const logger = winston.createLogger({
  level: process.env.NODE_ENV === 'production' ? 'warn' : 'debug',
  levels,
  transports,
  exitOnError: false,
});

// Create a stream object with a 'write' function that will be used by morgan
export const morganStream = {
  write: (message: string) => {
    logger.http(message.substring(0, message.lastIndexOf('\n')));
  },
};

export default logger;
</file>

<file path="src/middleware/auth.middleware.ts">
// src/middleware/auth.middleware.ts

import { Request, Response, NextFunction } from 'express';
import jwt from 'jsonwebtoken';
import prisma from '../lib/prisma';

// Extend Express's Request type to include our custom 'user' property
export interface AuthRequest extends Request {
  user?: { id: number; email: string; };
  merchant?: { id: number; status: 'PENDING' | 'APPROVED' | 'REJECTED' }; // For step 3
}

export const protect = async (req: AuthRequest, res: Response, next: NextFunction) => {
  let token;
  const jwtSecret = process.env.JWT_SECRET;

  if (!jwtSecret) {
    throw new Error('JWT_SECRET is not defined in the .env file');
  }

  if (req.headers.authorization && req.headers.authorization.startsWith('Bearer')) {
    try {
      token = req.headers.authorization.split(' ')[1];
      const decoded = jwt.verify(token, jwtSecret) as { userId: number; email: string };
      req.user = { id: decoded.userId, email: decoded.email };
      next();
    } catch (error) {
      return res.status(401).json({ error: 'Not authorized, token failed' });
    }
  }

  if (!token) {
    return res.status(401).json({ error: 'Not authorized, no token' });
  }
};

export const isApprovedMerchant = async (req: AuthRequest, res: Response, next: NextFunction) => {
  const userId = req.user?.id;

  if (!userId) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  try {
    const merchant = await prisma.merchant.findUnique({
      where: { ownerId: userId },
      select: { id: true, status: true },
    });

    if (!merchant) {
      return res.status(403).json({ error: 'You do not have a merchant profile.' });
    }

    if (merchant.status !== 'APPROVED') {
      return res.status(403).json({ error: `Your merchant profile is not approved. Current status: ${merchant.status}` });
    }

    // Attach merchant info to the request for use in the next handler
    req.merchant = merchant;
    next();
  } catch (error) {
    res.status(500).json({ error: 'Failed to verify merchant status' });
  }
};

// Middleware: require ADMIN role
export const requireAdmin = async (req: AuthRequest, res: Response, next: NextFunction) => {
  try {
    const userId = req.user?.id;
    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }
    const user = await prisma.user.findUnique({ where: { id: userId }, select: { role: true } });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    if (user.role !== 'ADMIN') {
      return res.status(403).json({ error: 'Admin access required' });
    }
    return next();
  } catch (err) {
    return res.status(500).json({ error: 'Failed to authorize admin' });
  }
};
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "target": "es2020", // Compile to a modern ECMAScript version
    "module": "commonjs", // Use the standard Node.js module system
  "rootDir": "./", // Include src and tests
    "outDir": "./dist", // Where the compiled JS output will go
    "esModuleInterop": true, // Allows for better interoperability between module systems
    "forceConsistentCasingInFileNames": true,
    "strict": true, // Enforces all strict type-checking options
    "skipLibCheck": true, // Speeds up compilation by skipping type checks on declaration files
    "types": ["node", "jest"]
  },
  "include": ["src/**/*", "tests/**/*", "jest.config.ts"],
  "exclude": ["dist", "node_modules"]
}
</file>

<file path="src/lib/email.ts">
// Switched from Brevo API to direct SMTP via Nodemailer. Previous Brevo implementation retained in comments for easy revert.
// import axios from 'axios';
import nodemailer from 'nodemailer';
import logger from './logging/logger';

export interface SendEmailOptions {
  to: string | { email: string; name?: string } | Array<string | { email: string; name?: string }>;
  subject: string;
  html: string;
  text?: string;
  tags?: string[];
}

function normalizeRecipients(to: SendEmailOptions['to']) {
  const arr = Array.isArray(to) ? to : [to];
  return arr.map(r => (typeof r === 'string' ? { email: r } : r));
}

// Environment variables for SMTP:
// SMTP_HOST, SMTP_PORT, SMTP_SECURE (true/false), SMTP_USER, SMTP_PASS
let _transporter: nodemailer.Transporter | null = null;

function getTransporter() {
  if (_transporter) return _transporter;
  let host = process.env.SMTP_HOST || '';
  let port = process.env.SMTP_PORT ? parseInt(process.env.SMTP_PORT, 10) : 587;
  let secure = (process.env.SMTP_SECURE || 'false').toLowerCase() === 'true';
  // Convenience Gmail support
  const provider = (process.env.EMAIL_PROVIDER || '').toLowerCase();
  // Allow alternate var names for ease of config
  let user = process.env.SMTP_USER || process.env.GMAIL_USER;
  let pass = process.env.SMTP_PASS || process.env.GMAIL_APP_PASSWORD || process.env.GMAIL_PASS;

  if (!host && provider === 'gmail') {
    host = 'smtp.gmail.com';
    port = 465; // recommended implicit TLS
    secure = true;
  }

  if (!host) {
    throw new Error('SMTP_HOST not configured (set SMTP_HOST or EMAIL_PROVIDER=gmail)');
  }
  if (user && pass) {
    _transporter = nodemailer.createTransport({ host, port, secure, auth: { user, pass } });
  } else {
    _transporter = nodemailer.createTransport({ host, port, secure });
  }
  return _transporter;
}

export async function sendEmail(options: SendEmailOptions): Promise<void> {
  const enabled = (process.env.EMAIL_ENABLED || 'false').toLowerCase() === 'true';
  if (!enabled) {
    logger.debug('[email] EMAIL_ENABLED not true – skipping send.');
    return;
  }
  const fromEmail = process.env.EMAIL_FROM_ADDRESS;
  const fromName = process.env.EMAIL_FROM_NAME || 'NoReply';
  if (!fromEmail) {
    logger.warn('[email] Missing EMAIL_FROM_ADDRESS – email disabled.');
    return;
  }
  try {
    const toList = normalizeRecipients(options.to);
    const transporter = getTransporter();
    await transporter.sendMail({
      from: `${fromName} <${fromEmail}>`,
      to: toList.map(t => (t.name ? `${t.name} <${t.email}>` : t.email)).join(', '),
      subject: options.subject,
      html: options.html,
      text: options.text || options.html.replace(/<[^>]+>/g, ''),
      headers: options.tags ? { 'X-Tags': options.tags.join(',') } : undefined,
    });
    logger.info(`[email] Sent email to ${toList.map(t=>t.email).join(', ')} subject="${options.subject}"`);
  } catch (err: any) {
    logger.error(`[email] SMTP send failed: err=${err.message}`);
  }
}

// Convenience helpers (extend as needed)
export async function sendWelcomeEmail(to: string, name?: string) {
  const subject = 'Welcome to YOHOP! 🎉';
  const safeName = name ? name.split(/\s+/)[0] : '';
  const html = `
    <div style="font-family:Arial,Helvetica,sans-serif;font-size:15px;line-height:1.5;color:#222;background:#f9fafb;padding:24px;">
      <table role="presentation" width="100%" cellpadding="0" cellspacing="0" style="max-width:600px;margin:0 auto;background:#ffffff;border:1px solid #e5e7eb;border-radius:8px;overflow:hidden;">
        <tr>
          <td style="background:#111827;padding:18px 24px;">
            <h1 style="margin:0;font-size:20px;color:#ffffff;font-weight:600;">YOHOP</h1>
          </td>
        </tr>
        <tr>
          <td style="padding:24px;">
            <p style="margin-top:0;">Hi ${safeName || 'there'},</p>
            <p style="margin:16px 0;">Welcome to <strong>YOHOP</strong> — we’re excited to have you on board! Your account is set up and you’ve already earned your signup points.</p>
            <p style="margin:16px 0;">Here’s what you can do next:</p>
            <ol style="padding-left:20px;margin:16px 0;">
              <li><strong>Explore deals</strong> near you and start checking in.</li>
              <li><strong>Earn points</strong> for check-ins and activity.</li>
              <li><strong>Share your referral code</strong> (find it in your profile) to earn bonus points when friends join.</li>
            </ol>
            <p style="margin:16px 0;">Need help? Just reply to this email — we actually read these.</p>
            <p style="margin:24px 0 0;">Cheers,<br/>The YOHOP Team</p>
          </td>
        </tr>
        <tr>
          <td style="background:#f3f4f6;padding:16px 24px;font-size:12px;color:#6b7280;">
            <p style="margin:0;">You’re receiving this because you created a YOHOP account. If this wasn’t you, ignore this email.</p>
          </td>
        </tr>
      </table>
    </div>
  `;
  await sendEmail({ to: { email: to }, subject, html, tags: ['welcome'] });
}

// Notify a referrer that someone used their code successfully.
export async function sendReferralSuccessEmail(params: { to: string; referrerName?: string; referredEmail: string; referralCode: string }) {
  const { to, referrerName, referredEmail, referralCode } = params;
  const safeName = referrerName ? referrerName.split(/\s+/)[0] : '';
  const subject = 'Your referral just joined YOHOP! 🎉';
  const html = `
    <div style="font-family:Arial,Helvetica,sans-serif;font-size:15px;line-height:1.5;color:#222;background:#f9fafb;padding:24px;">
      <table role="presentation" width="100%" cellpadding="0" cellspacing="0" style="max-width:600px;margin:0 auto;background:#ffffff;border:1px solid #e5e7eb;border-radius:8px;overflow:hidden;">
        <tr>
          <td style="background:#111827;padding:18px 24px;">
            <h1 style="margin:0;font-size:20px;color:#ffffff;font-weight:600;">YOHOP</h1>
          </td>
        </tr>
        <tr>
          <td style="padding:24px;">
            <p style="margin-top:0;">Hi ${safeName || 'there'},</p>
            <p style="margin:16px 0;">Great news — <strong>${referredEmail}</strong> just signed up using your referral code <code style="background:#f3f4f6;padding:2px 4px;border-radius:4px;">${referralCode}</code>.</p>
            <p style="margin:16px 0;">You’ve earned referral progress toward rewards. Keep sharing your code to climb the leaderboard and unlock more points.</p>
            <p style="margin:16px 0;">Need your code again? You can always find it in your profile.</p>
            <p style="margin:24px 0 0;">Thanks for growing the community!<br/>The YOHOP Team</p>
          </td>
        </tr>
        <tr>
          <td style="background:#f3f4f6;padding:16px 24px;font-size:12px;color:#6b7280;">
            <p style="margin:0;">You’re receiving this because someone joined YOHOP using your referral code.</p>
          </td>
        </tr>
      </table>
    </div>
  `;
  await sendEmail({ to: { email: to }, subject, html, tags: ['referral-success'] });
}

// Simple birthday greeting email
export async function sendBirthdayEmail(params: { to: string; name?: string }) {
  const { to, name } = params;
  const first = name ? name.split(/\s+/)[0] : 'there';
  const subject = 'Happy Birthday from YOHOP! 🎂';
  const html = `
    <div style="font-family:Arial,Helvetica,sans-serif;font-size:15px;line-height:1.5;color:#222;background:#f9fafb;padding:24px;">
      <table role="presentation" width="100%" cellpadding="0" cellspacing="0" style="max-width:600px;margin:0 auto;background:#ffffff;border:1px solid #e5e7eb;border-radius:8px;overflow:hidden;">
        <tr>
          <td style="background:#111827;padding:18px 24px;">
            <h1 style="margin:0;font-size:20px;color:#ffffff;font-weight:600;">YOHOP</h1>
          </td>
        </tr>
        <tr>
          <td style="padding:24px;">
            <p style="margin-top:0;">Hi ${first},</p>
            <p style="margin:16px 0;">All of us at <strong>YOHOP</strong> wish you a very Happy Birthday! 🎉</p>
            <p style="margin:16px 0;">We hope you discover great deals and earn tons of points today. Treat yourself!</p>
            <p style="margin:24px 0 0;">Cheers,<br/>The YOHOP Team</p>
          </td>
        </tr>
        <tr>
          <td style="background:#f3f4f6;padding:16px 24px;font-size:12px;color:#6b7280;">
            <p style="margin:0;">You’re receiving this because your birthday is set in YOHOP. If this seems wrong you can update your profile.</p>
          </td>
        </tr>
      </table>
    </div>`;
  await sendEmail({ to: { email: to }, subject, html, tags: ['birthday'] });
}
</file>

<file path="src/lib/leaderboard/leaderboard.ts">
// src/lib/leaderboard/leaderboard.ts
// Core leaderboard query + ranking logic.

import prisma from '../prisma';
import { resolvePeriod, ResolvePeriodInput } from './period';
import { cacheTtlForGranularity, getCache, invalidateLeaderboardCache, makeKey, setCache } from './cache';

export interface LeaderboardRow {
  userId: number;
  name: string | null;
  periodPoints: number;
  totalPoints: number;
  rank: number; // assigned after tie-aware ranking
}

export interface LeaderboardResult {
  period: { granularity: string; start: string; endExclusive: string; label: string };
  top: LeaderboardRow[];
  me?: LeaderboardRow & { inTop: boolean };
}

interface GetLeaderboardArgs extends ResolvePeriodInput {
  limit?: number;
  includeSelf?: boolean;
  selfUserId?: number; // optional authenticated user id
}

export async function getLeaderboard(args: GetLeaderboardArgs): Promise<LeaderboardResult> {
  const { limit = 10, includeSelf = true, selfUserId } = args;
  if (limit <= 0 || limit > 50) throw new Error('limit must be 1-50');

  const period = resolvePeriod(args);

  // Attempt cache (top list only, not personalized 'me')
  const cacheKey = makeKey({ granularity: period.granularity, start: period.start.toISOString(), end: period.endExclusive.toISOString(), limit });
  let cached = getCache<LeaderboardRow[]>(cacheKey);

  // Raw period aggregation for top users (unless cached)
  let topRaw: { id: number; name: string | null; period_points: bigint | number; total_points: number; }[];
  const isCurrentMonth = period.granularity === 'month' && (() => { const now = new Date(); return now.getUTCFullYear() === period.start.getUTCFullYear() && now.getUTCMonth() === period.start.getUTCMonth(); })();
  if (!cached) {
  if (isCurrentMonth) {
    // Fast path: current month uses live monthlyPoints
    topRaw = await prisma.$queryRawUnsafe(
      `SELECT id, name, "monthlyPoints" AS period_points, points as total_points
       FROM "User" WHERE "monthlyPoints" > 0
       ORDER BY "monthlyPoints" DESC, id ASC
       LIMIT $1`,
      limit
    );
  } else {
    topRaw = await prisma.$queryRawUnsafe(
      `SELECT u.id, u.name, SUM(e.points) AS period_points, u.points as total_points
       FROM "UserPointEvent" e
       JOIN "User" u ON u.id = e."userId"
       WHERE e."createdAt" >= $1 AND e."createdAt" < $2
       GROUP BY u.id
       ORDER BY period_points DESC, u.id ASC
       LIMIT $3`,
      period.start,
      period.endExclusive,
      limit
    );
  }
  } else {
    topRaw = cached.map(r => ({ id: r.userId, name: r.name, period_points: r.periodPoints, total_points: r.totalPoints }));
  }

  // Convert to rows and later assign ranks
  const topPreRank: LeaderboardRow[] = topRaw.map((r) => ({
    userId: r.id,
    name: r.name,
    periodPoints: Number(r.period_points),
    totalPoints: Number(r.total_points),
    rank: 0
  }));

  if (!cached) {
    // Assign competition ranks (1,1,3 style)
    let lastPoints: number | null = null;
    let lastRank = 0;
    topPreRank.forEach((row: LeaderboardRow, idx: number) => {
      if (lastPoints === null || row.periodPoints < lastPoints) {
        lastRank = idx + 1;
        lastPoints = row.periodPoints;
      }
      row.rank = lastRank;
    });
    // Store in cache
    setCache(cacheKey, topPreRank, cacheTtlForGranularity(period.granularity));
  }

  let me: LeaderboardResult['me'];

  if (selfUserId && includeSelf) {
    const inTop = topPreRank.some((r: LeaderboardRow) => r.userId === selfUserId);
    if (inTop) {
      const row = topPreRank.find((r: LeaderboardRow) => r.userId === selfUserId)!;
      me = { ...row, inTop: true };
    } else {
      let myPoints: number;
      if (isCurrentMonth) {
        const user = await prisma.user.findUnique({ where: { id: selfUserId }, select: { id: true } });
        // @ts-ignore monthlyPoints added in migration
        const mp = (user as any)?.monthlyPoints;
        myPoints = mp || 0;
      } else {
        const personal = await prisma.$queryRawUnsafe<{ me_points: bigint | number }[]>(
          `SELECT COALESCE(SUM(points),0) as me_points
           FROM "UserPointEvent"
           WHERE "userId" = $1 AND "createdAt" >= $2 AND "createdAt" < $3`,
          selfUserId,
          period.start,
          period.endExclusive
        );
        myPoints = Number(personal[0]?.me_points || 0);
      }

      if (myPoints > 0) {
        // Count users strictly above
        let higher: { higher: bigint | number }[];
        if (isCurrentMonth) {
          higher = await prisma.$queryRawUnsafe(
            `SELECT COUNT(*) as higher FROM "User" WHERE "monthlyPoints" > $1`,
            myPoints
          );
        } else {
          higher = await prisma.$queryRawUnsafe(
            `SELECT COUNT(*) as higher FROM (
               SELECT "userId", SUM(points) s
               FROM "UserPointEvent"
               WHERE "createdAt" >= $1 AND "createdAt" < $2
               GROUP BY "userId"
               HAVING SUM(points) > $3
             ) t`,
            period.start,
            period.endExclusive,
            myPoints
          );
        }
        const myRank = Number(higher[0]?.higher || 0) + 1;
        // Fetch total points + name
        const user = await prisma.user.findUnique({ where: { id: selfUserId }, select: { id: true, name: true, points: true } });
        if (user) {
          me = { userId: user.id, name: user.name, periodPoints: myPoints, totalPoints: user.points, rank: myRank, inTop: false };
        }
      } else {
        // No points this period -> still return base identity with rank undefined? We'll omit rank for 0-case.
        const user = await prisma.user.findUnique({ where: { id: selfUserId }, select: { id: true, name: true, points: true } });
        if (user) {
          me = { userId: user.id, name: user.name, periodPoints: 0, totalPoints: user.points, rank: 0, inTop: false };
        }
      }
    }
  }

  return {
    period: {
      granularity: period.granularity,
      start: period.start.toISOString(),
      endExclusive: period.endExclusive.toISOString(),
      label: period.label
    },
    top: topPreRank,
    me
  };
}
</file>

<file path="README_PROD.md">
# Production Deployment Notes

## Welcome Email Feature

The application sends a non‑blocking “Welcome” email immediately after a user successfully registers (`POST /api/auth/register`). The send is fire‑and‑forget so it will not delay the API response. Failures are logged but do not affect user creation.

### Flow Summary
 
* Column `birthday` (nullable) added to `User` table.
* Scheduler (`scheduleDailyBirthdays`) runs once per day shortly after 00:00:00 UTC.
* It queries users with matching month/day using a raw SQL filter with `EXTRACT(MONTH|DAY FROM birthday)`.
* For each match we invoke `sendBirthdayEmail()` (fire & forget) tagged with `birthday`.
4. If email sending is disabled or misconfigured, the call exits gracefully (no throw).

 
Currently there is no public API endpoint for setting a birthday (future enhancement). You can populate via SQL or an admin script:

```sql
UPDATE "User" SET birthday = '1995-09-11' WHERE id = 123;
```
| Variable | Required | Description |
|----------|----------|-------------|
 
Uses the same email gating (`EMAIL_ENABLED`) and provider credentials as other transactional emails. If email is disabled nothing happens beyond a debug skip.
| `BREVO_API_KEY` | Yes (if enabled) | Brevo (Sendinblue) API key. |
| `EMAIL_FROM_ADDRESS` | Yes (if enabled) | Sender envelope/from address. |
 
* Award birthday bonus points.
* User self‑service birthday update with immutability rules.
* Batch queue and retry logic.
* Local timezone handling (currently strict UTC midnight).
### Enabling in Production

Set the following (example):

```bash
EMAIL_ENABLED=true
BREVO_API_KEY=xxxxxxxxxxxxxxxx
EMAIL_FROM_ADDRESS=noreply@yourdomain.com
EMAIL_FROM_NAME=YOHOP
```

Restart the service after updating environment variables.

### Observability & Logging

Logs (via Winston) will show:

* Info log on success: `[email] Sent email to user@example.com subject="Welcome to YOHOP! 🎉"`
* Debug log (only if disabled): `[email] EMAIL_ENABLED not true – skipping send.`
* Warning if required config missing.
* Error with status code + response body if Brevo rejects the request.

### Safety / Failure Modes

* Missing or invalid config: silently skips sending (no user impact).
* External API timeout (>10s) logs an error, request already returned 201 to client.
* Any thrown error inside `sendWelcomeEmail` is caught in the route via the `.catch` handler.

### Testing

`tests/welcome.email.test.ts` mocks `sendEmail` and asserts the welcome tag is applied. Run the full suite locally with `npm test`. (User requested not to auto-run in this environment.)

### Extending the Template

* Inject referral code & initial points into the email body.
* Add a transactional template ID instead of raw HTML (if moving to provider managed templates).
* Queue / retry mechanism (e.g., BullMQ) for improved resilience.

---

This document section was added to clarify the production configuration for the welcome email feature.

## Birthday Email Feature

The system now sends a simple "Happy Birthday" greeting email to users whose stored `birthday` (UTC date) matches the current UTC month/day.

### How It Works
* Column `birthday` (nullable) added to `User` table.
* Scheduler (`scheduleDailyBirthdays`) runs once per day shortly after 00:00:00 UTC.
* It queries users with matching month/day using a raw SQL filter with `EXTRACT(MONTH|DAY FROM birthday)`.
* For each match we invoke `sendBirthdayEmail()` (fire & forget) tagged with `birthday`.

### Adding / Updating Birthdays
Currently there is no public API endpoint for setting a birthday (future enhancement). You can populate via SQL or an admin script:
```sql
UPDATE "User" SET birthday = '1995-09-11' WHERE id = 123;
```
Year may be any valid year; only month/day are used for matching.

### Environment / Safety
Uses the same email gating (`EMAIL_ENABLED`) and provider credentials as other transactional emails. If email is disabled nothing happens beyond a debug skip.

### Future Enhancements
* Award birthday bonus points.
* User self‑service birthday update with immutability rules.
* Batch queue and retry logic.
* Local timezone handling (currently strict UTC midnight).

---

## Cities and Stores

This version introduces normalized Cities and Stores for city-wise listings and multiple merchant locations.

Data models:
- City: id, name, state, active, createdAt, updatedAt
- Store: id, merchantId, cityId, address, latitude, longitude, active, timestamps

Key endpoints:
- GET `/api/cities?active=true&q=seattle` – list cities (filter by active and search).
- POST `/api/cities/toggle` (admin) – body `{ cityId, active }`.
- POST `/api/merchants/register` – accepts optional `cityId` OR `cityName`+`state` to create the first Store; if omitted, legacy `city` string is stored on `Merchant`.

Seeding 20+ US cities: run the seed script after migrations to pre-populate cities. Some cities are marked active by default: Florida (Miami, Orlando, Tampa), Atlanta (GA), New York (NY), Texas (Dallas, Houston, Austin), and Seattle (WA).
</file>

<file path="src/app.ts">
import express, { Express, Request, Response } from 'express';
import prisma from './lib/prisma';
import dotenv from 'dotenv';
import cors from 'cors';
import helmet from 'helmet';
import rateLimit from 'express-rate-limit';

// Routes
import authRoutes from './routes/auth.routes';
import merchantRoutes from './routes/merchant.routes';
import publicDealRoutes from './routes/deals.public.routes';
import userRoutes from './routes/user.routes';
import leaderboardRoutes from './routes/leaderboard.routes';
import adminRoutes from './routes/admin.routes';
import cityRoutes from './routes/cities.routes';

// Load env (tests can set process.env before importing this file)
dotenv.config();

const app: Express = express();

app.use(cors());
app.use(express.json());
app.use(helmet());

// Basic rate limiting (disabled in test for speed)
if (process.env.NODE_ENV !== 'test') {
  const apiLimiter = rateLimit({
    windowMs: 15 * 60 * 1000,
    limit: 200,
    standardHeaders: true,
    legacyHeaders: false,
  });
  app.use('/api/', apiLimiter);
}

app.get('/', (req: Request, res: Response) => {
  res.send('YOHOP Server (TypeScript & Prisma Edition) is alive!');
});

// Mount routes
app.use('/api/auth', authRoutes);
app.use('/api', merchantRoutes);
app.use('/api', publicDealRoutes);
app.use('/api/users', userRoutes);
app.use('/api/leaderboard', leaderboardRoutes);
app.use('/api/admin', adminRoutes);
app.use('/api', cityRoutes);

export default app;

// Utility to help tests clean DB safely
export async function resetDatabase() {
  // Ensure we are not pointing at production DB
  const url = process.env.DATABASE_URL || '';
  if (!url || /prod|production/i.test(url)) {
    throw new Error('Refusing to reset database: DATABASE_URL appears to be production.');
  }
  // Truncate in dependency-safe order using CASCADE
  await prisma.$executeRawUnsafe('TRUNCATE TABLE "UserPointEvent","CheckIn","UserDeal","Deal","Merchant","User" RESTART IDENTITY CASCADE;');
}
</file>

<file path="src/routes/admin.routes.ts">
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import prisma from '../lib/prisma';
import { protect, AuthRequest } from '../middleware/auth.middleware';

const router = Router();

// Admin middleware - only allow ADMIN role
const requireAdmin = (req: AuthRequest, res: Response, next: Function) => {
  if (!req.user) {
    return res.status(401).json({ error: 'Authentication required' });
  }

  // Get user with role information
  prisma.user.findUnique({
    where: { id: req.user.id },
    select: { role: true }
  }).then(user => {
    if (!user || user.role !== 'ADMIN') {
      return res.status(403).json({ error: 'Admin access required' });
    }
    next();
  }).catch(error => {
    console.error('Admin check error:', error);
    res.status(500).json({ error: 'Internal server error' });
  });
};

// Validation schemas
const updateCityActiveSchema = z.object({
  active: z.boolean()
});

const bulkUpdateCitiesSchema = z.object({
  cityIds: z.array(z.number().int().positive()),
  active: z.boolean()
});

// --- Endpoint: GET /api/admin/cities ---
// Get all cities with pagination and filtering
router.get('/cities', protect, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const page = parseInt(req.query.page as string) || 1;
    const limit = parseInt(req.query.limit as string) || 50;
    const active = req.query.active as string;
    const search = req.query.search as string;
    const state = req.query.state as string;

    const skip = (page - 1) * limit;

    // Build where clause
    const where: any = {};
    
    if (active !== undefined) {
      where.active = active === 'true';
    }
    
    if (search) {
      where.OR = [
        { name: { contains: search, mode: 'insensitive' } },
        { state: { contains: search, mode: 'insensitive' } }
      ];
    }
    
    if (state) {
      where.state = { contains: state, mode: 'insensitive' };
    }

    // Get cities with store count
    const [cities, totalCount] = await Promise.all([
      prisma.city.findMany({
        where,
        include: {
          stores: {
            select: {
              id: true,
              active: true,
              merchant: {
                select: {
                  businessName: true,
                  status: true
                }
              }
            }
          },
          _count: {
            select: {
              stores: true
            }
          }
        },
        orderBy: [
          { state: 'asc' },
          { name: 'asc' }
        ],
        skip,
        take: limit
      }),
      prisma.city.count({ where })
    ]);

    // Calculate active store counts
    const citiesWithStats = cities.map(city => ({
      id: city.id,
      name: city.name,
      state: city.state,
      active: city.active,
      createdAt: city.createdAt,
      updatedAt: city.updatedAt,
      totalStores: city._count.stores,
      activeStores: city.stores.filter(store => store.active).length,
      approvedMerchants: city.stores.filter(store => 
        store.merchant.status === 'APPROVED' && store.active
      ).length
    }));

    res.status(200).json({
      message: 'Cities retrieved successfully',
      cities: citiesWithStats,
      pagination: {
        page,
        limit,
        totalCount,
        totalPages: Math.ceil(totalCount / limit),
        hasNext: page * limit < totalCount,
        hasPrev: page > 1
      }
    });

  } catch (error) {
    console.error('Get cities error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: PUT /api/admin/cities/:cityId/active ---
// Update a single city's active state
router.put('/cities/:cityId/active', protect, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const cityId = parseInt(req.params.cityId);
    const { active } = updateCityActiveSchema.parse(req.body);

    if (isNaN(cityId)) {
      return res.status(400).json({ error: 'Invalid city ID' });
    }

    // Check if city exists
    const existingCity = await prisma.city.findUnique({
      where: { id: cityId },
      include: {
        _count: {
          select: {
            stores: true
          }
        }
      }
    });

    if (!existingCity) {
      return res.status(404).json({ error: 'City not found' });
    }

    // Update city active state
    const updatedCity = await prisma.city.update({
      where: { id: cityId },
      data: { active },
      include: {
        _count: {
          select: {
            stores: true
          }
        }
      }
    });

    res.status(200).json({
      message: `City ${active ? 'activated' : 'deactivated'} successfully`,
      city: {
        id: updatedCity.id,
        name: updatedCity.name,
        state: updatedCity.state,
        active: updatedCity.active,
        totalStores: updatedCity._count.stores,
        updatedAt: updatedCity.updatedAt
      }
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.issues });
    }
    console.error('Update city active state error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: PUT /api/admin/cities/bulk-update ---
// Bulk update multiple cities' active state
router.put('/cities/bulk-update', protect, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const { cityIds, active } = bulkUpdateCitiesSchema.parse(req.body);

    if (cityIds.length === 0) {
      return res.status(400).json({ error: 'At least one city ID is required' });
    }

    if (cityIds.length > 100) {
      return res.status(400).json({ error: 'Cannot update more than 100 cities at once' });
    }

    // Check if all cities exist
    const existingCities = await prisma.city.findMany({
      where: {
        id: { in: cityIds }
      },
      select: { id: true, name: true, state: true }
    });

    if (existingCities.length !== cityIds.length) {
      const foundIds = existingCities.map(c => c.id);
      const missingIds = cityIds.filter(id => !foundIds.includes(id));
      return res.status(404).json({ 
        error: 'Some cities not found',
        missingIds
      });
    }

    // Bulk update cities
    const updateResult = await prisma.city.updateMany({
      where: {
        id: { in: cityIds }
      },
      data: { active }
    });

    res.status(200).json({
      message: `${updateResult.count} cities ${active ? 'activated' : 'deactivated'} successfully`,
      updatedCount: updateResult.count,
      cityIds: cityIds,
      active
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.issues });
    }
    console.error('Bulk update cities error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/admin/cities/stats ---
// Get city statistics for admin dashboard
router.get('/cities/stats', protect, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const [
      totalCities,
      activeCities,
      inactiveCities,
      citiesWithStores,
      activeCitiesWithStores
    ] = await Promise.all([
      prisma.city.count(),
      prisma.city.count({ where: { active: true } }),
      prisma.city.count({ where: { active: false } }),
      prisma.city.count({
        where: {
          stores: {
            some: {}
          }
        }
      }),
      prisma.city.count({
        where: {
          active: true,
          stores: {
            some: {}
          }
        }
      })
    ]);

    // Get top cities by store count
    const topCitiesByStores = await prisma.city.findMany({
      include: {
        _count: {
          select: {
            stores: true
          }
        }
      },
      orderBy: {
        stores: {
          _count: 'desc'
        }
      },
      take: 10
    });

    res.status(200).json({
      message: 'City statistics retrieved successfully',
      stats: {
        totalCities,
        activeCities,
        inactiveCities,
        citiesWithStores,
        activeCitiesWithStores,
        topCitiesByStores: topCitiesByStores.map(city => ({
          id: city.id,
          name: city.name,
          state: city.state,
          active: city.active,
          storeCount: city._count.stores
        }))
      }
    });

  } catch (error) {
    console.error('Get city stats error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: POST /api/admin/cities ---
// Create a new city (admin only)
router.post('/cities', protect, requireAdmin, async (req: AuthRequest, res: Response) => {
  try {
    const createCitySchema = z.object({
      name: z.string().min(1, 'City name is required'),
      state: z.string().min(1, 'State is required'),
      active: z.boolean().default(false)
    });

    const { name, state, active } = createCitySchema.parse(req.body);

    // Check if city already exists
    const existingCity = await prisma.city.findUnique({
      where: {
        name_state: {
          name: name.trim(),
          state: state.trim()
        }
      }
    });

    if (existingCity) {
      return res.status(409).json({ 
        error: 'City already exists',
        existingCity: {
          id: existingCity.id,
          name: existingCity.name,
          state: existingCity.state,
          active: existingCity.active
        }
      });
    }

    // Create new city
    const newCity = await prisma.city.create({
      data: {
        name: name.trim(),
        state: state.trim(),
        active
      }
    });

    res.status(201).json({
      message: 'City created successfully',
      city: {
        id: newCity.id,
        name: newCity.name,
        state: newCity.state,
        active: newCity.active,
        createdAt: newCity.createdAt
      }
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.issues });
    }
    console.error('Create city error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="env.production.example">
# Production Environment Configuration
NODE_ENV=production
PORT=3000

# Database Configuration
DATABASE_URL=postgresql://username:password@localhost:5432/geolocationmvp_prod

# JWT Configuration
JWT_SECRET=your-super-secure-jwt-secret-key-here-change-this-in-production
JWT_EXPIRES_IN=24h

# CORS Configuration
ALLOWED_ORIGINS=https://yourdomain.com,https://www.yourdomain.com,https://api.yourdomain.com

# Logging Configuration
LOG_LEVEL=warn
LOG_DIR=logs

# Backup Configuration
BACKUP_SCHEDULE=0 2 * * *
BACKUP_RETENTION_DAYS=30

# Security Configuration
BCRYPT_ROUNDS=12
RATE_LIMIT_WINDOW_MS=900000
RATE_LIMIT_MAX_REQUESTS=100

# Monitoring Configuration
HEALTH_CHECK_INTERVAL=30000
METRICS_ENABLED=true

# Performance Configuration
REQUEST_TIMEOUT_MS=30000
MAX_REQUEST_SIZE=10mb

# Gamification / Points Configuration
# Default signup points (fallback 50 if unset or invalid)
SIGNUP_POINTS=50
# Points for each successful check-in (fallback 10)
CHECKIN_POINTS=10
# Bonus points for the first check-in per deal (fallback 25)
FIRST_CHECKIN_BONUS_POINTS=25
# Max distance in meters to qualify for a check-in (fallback 100)
CHECKIN_RADIUS_METERS=100

# Leaderboard Cache Configuration
# Override default TTL (seconds) for all leaderboard entries; leave unset to use tiered defaults.
# LEADERBOARD_CACHE_TTL_SECONDS=120

# Email Configuration (SMTP via Nodemailer)
# Set to true to enable sending emails
EMAIL_ENABLED=false
EMAIL_FROM_ADDRESS=noreply@yourdomain.com
EMAIL_FROM_NAME=YOHOP

# SMTP Settings
SMTP_HOST=smtp.yourdomain.com
SMTP_PORT=587
SMTP_SECURE=false
SMTP_USER=
SMTP_PASS=

# Optional: use Gmail (preferred with App Password)
# EMAIL_PROVIDER=gmail
# GMAIL_USER=yourgmail@gmail.com
# GMAIL_APP_PASSWORD=your-16-char-app-password

# (Legacy Brevo config retained for reference – currently unused)
# BREVO_API_KEY=your-brevo-api-key
</file>

<file path="src/routes/deals.public.routes.ts">
// src/routes/deals.public.routes.ts

import { Router } from 'express';
import prisma from '../lib/prisma';

const router = Router();

// Utility function to calculate distance between two points using Haversine formula
function calculateDistance(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371; // Earth's radius in kilometers
  const dLat = (lat2 - lat1) * Math.PI / 180;
  const dLon = (lon2 - lon1) * Math.PI / 180;
  const a = 
    Math.sin(dLat/2) * Math.sin(dLat/2) +
    Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) * 
    Math.sin(dLon/2) * Math.sin(dLon/2);
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
  return R * c; // Distance in kilometers
}

// Utility function to format deal data for frontend consumption
function formatDealForFrontend(deal: any, distance?: number) {
  return {
    id: deal.id,
    title: deal.title || '',
    description: deal.description || '',
    imageUrl: deal.imageUrl || null,
    discountPercentage: deal.discountPercentage || null,
    discountAmount: deal.discountAmount || null,
    category: deal.category || 'OTHER',
    dealType: deal.dealType || 'STANDARD',
    recurringDays: deal.recurringDays || null,
    startTime: deal.startTime?.toISOString() || null,
    endTime: deal.endTime?.toISOString() || null,
    redemptionInstructions: deal.redemptionInstructions || '',
    createdAt: deal.createdAt?.toISOString() || null,
    updatedAt: deal.updatedAt?.toISOString() || null,
    merchantId: deal.merchantId,
    merchant: {
      id: deal.merchant?.id || null,
      businessName: deal.merchant?.businessName || '',
      address: deal.merchant?.address || '',
      description: deal.merchant?.description || null,
      logoUrl: deal.merchant?.logoUrl || null,
      latitude: deal.merchant?.latitude || null,
      longitude: deal.merchant?.longitude || null,
      status: deal.merchant?.status || 'PENDING',
      createdAt: deal.merchant?.createdAt?.toISOString() || null,
      updatedAt: deal.merchant?.updatedAt?.toISOString() || null,
    },
    ...(distance !== undefined && { distance: Math.round(distance * 100) / 100 }), // Round to 2 decimal places
  };
}

// Performance monitoring utility
function logQueryPerformance(operation: string, startTime: number, resultCount: number, filters?: any) {
  const duration = Date.now() - startTime;
  console.log(`[PERFORMANCE] ${operation}: ${duration}ms, ${resultCount} results`, filters ? `Filters: ${JSON.stringify(filters)}` : '');
  
  // Log slow queries for optimization
  if (duration > 1000) {
    console.warn(`[SLOW QUERY] ${operation} took ${duration}ms - consider optimization`);
  }
}

// --- Endpoint: GET /api/deals ---
// Fetches all active deals from approved merchants.
// Optional query parameters: latitude, longitude, radius (in kilometers), category, search
router.get('/deals', async (req, res) => {
  try {
    const { latitude, longitude, radius, category, search, cityId } = req.query as any;
    const now = new Date();
  // Determine today's weekday name for recurring deal filtering (server local time)
  const dayNames = ['SUNDAY','MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY'];
  const todayName = dayNames[now.getDay()];
    
    // Build the where clause for filtering
    const whereClause: any = {
      // Filter for active deals
      startTime: { lte: now },
      endTime: { gte: now },
      // IMPORTANT: Only show deals from approved merchants
      merchant: {
        status: 'APPROVED',
      },
    };

    // Add category filter if provided
    if (category) {
      // Validate category
      const validCategories = [
        'FOOD_AND_BEVERAGE', 'RETAIL', 'ENTERTAINMENT', 'HEALTH_AND_FITNESS',
        'BEAUTY_AND_SPA', 'AUTOMOTIVE', 'TRAVEL', 'EDUCATION', 'TECHNOLOGY',
        'HOME_AND_GARDEN', 'OTHER'
      ];
      
      if (!validCategories.includes(category as string)) {
        return res.status(400).json({
          error: `Invalid category. Must be one of: ${validCategories.join(', ')}`
        });
      }
      
      whereClause.category = category;
    }

    // Add search filter if provided
    if (search && typeof search === 'string' && search.trim().length > 0) {
      const searchTerm = search.trim();
      
      // Validate search term length
      if (searchTerm.length < 2) {
        return res.status(400).json({
          error: 'Search term must be at least 2 characters long.'
        });
      }
      
      if (searchTerm.length > 100) {
        return res.status(400).json({
          error: 'Search term must be no more than 100 characters long.'
        });
      }
      
      // Search in both title and description using case-insensitive contains
      whereClause.OR = [
        {
          title: {
            contains: searchTerm,
            mode: 'insensitive' // Case-insensitive search
          }
        },
        {
          description: {
            contains: searchTerm,
            mode: 'insensitive' // Case-insensitive search
          }
        }
      ];
    }
    
    // Base query for active deals from approved merchants
    // Optimized to use database indexes efficiently
    const queryStartTime = Date.now();
    // @ts-ignore: Prisma types will include merchant.stores after generate
    let deals: any[] = await prisma.deal.findMany({
      where: whereClause,
      include: {
        // @ts-ignore
        merchant: { include: { stores: { include: { city: true } } } },
      },
      orderBy: {
        createdAt: 'desc',
      },
      // Add query hints for better performance
      // This helps PostgreSQL choose the right indexes
    });

    // Filter recurring deals so they only appear on their specified day(s)
    // recurringDays stored as comma-separated list of day names (MONDAY,...)
    if (deals.length) {
      deals = deals.filter(d => {
        if (d.dealType !== 'RECURRING') return true;
        if (!d.recurringDays) return false; // malformed recurring deal, hide
  const days = d.recurringDays.split(',').map((s: string) => s.trim().toUpperCase());
        return days.includes(todayName);
      });
    }

    // Log query performance
    logQueryPerformance('Deals Query', queryStartTime, deals.length, {
      category: category || 'all',
      search: search ? 'yes' : 'no',
      geolocation: (latitude && longitude && radius) ? 'yes' : 'no'
    });

    // If a cityId filter is provided, filter deals by merchant's stores in that city
    if (cityId) {
      const cid = Number(cityId);
      if (!Number.isFinite(cid)) {
        return res.status(400).json({ error: 'cityId must be a number' });
      }
      deals = deals.filter(d => Array.isArray((d as any).merchant.stores) && (d as any).merchant.stores.some((s: any) => s.cityId === cid));
    }

    // If coordinates and radius are provided, filter by distance
    if (latitude && longitude && radius) {
      const userLat = parseFloat(latitude as string);
      const userLon = parseFloat(longitude as string);
      const radiusKm = parseFloat(radius as string);

      // Validate input parameters
      if (isNaN(userLat) || isNaN(userLon) || isNaN(radiusKm)) {
        return res.status(400).json({ 
          error: 'Invalid parameters. latitude, longitude, and radius must be valid numbers.' 
        });
      }

      if (userLat < -90 || userLat > 90) {
        return res.status(400).json({ 
          error: 'Latitude must be between -90 and 90 degrees.' 
        });
      }

      if (userLon < -180 || userLon > 180) {
        return res.status(400).json({ 
          error: 'Longitude must be between -180 and 180 degrees.' 
        });
      }

      if (radiusKm <= 0) {
        return res.status(400).json({ 
          error: 'Radius must be a positive number.' 
        });
      }

      // Use database-level geospatial filtering for better performance
      // This leverages the merchant status + coordinates index
      whereClause.merchant = {
        ...whereClause.merchant,
        latitude: { not: null },
        longitude: { not: null },
      };

      // Re-query with geospatial constraints
      deals = await prisma.deal.findMany({
        where: whereClause,
        include: {
          merchant: {
            select: {
              id: true,
              businessName: true,
              address: true,
              description: true,
              logoUrl: true,
              latitude: true,
              longitude: true,
              status: true,
              createdAt: true,
              updatedAt: true,
            },
          },
        },
        orderBy: {
          createdAt: 'desc',
        },
      });

      // Filter by distance and add distance information
      const dealsWithDistance = (deals as any[])
        .filter(deal => {
          if (!deal.merchant?.latitude || !deal.merchant?.longitude) {
            return false;
          }

          const distance = calculateDistance(
            userLat, 
            userLon, 
            deal.merchant.latitude, 
            deal.merchant.longitude
          );

          return distance <= radiusKm;
        })
        .map(deal => {
          const distance = calculateDistance(
            userLat, 
            userLon, 
            deal.merchant.latitude!, 
            deal.merchant.longitude!
          );
          return formatDealForFrontend(deal, distance);
        })
        .sort((a, b) => (a.distance || 0) - (b.distance || 0));

      deals = dealsWithDistance;
    } else {
      // Format deals for frontend when no geolocation filtering is applied
      deals = deals.map(deal => formatDealForFrontend(deal));
    }

    // Prioritize active HAPPY_HOUR deals at the top while preserving distance or createdAt ordering within groups
    if (Array.isArray(deals) && deals.length) {
      const isFormatted = !('merchant' in deals[0] && !(deals[0] as any).merchant.businessName); // naive check
      // deals are already formatted above (or include distance) at this point
      const happyHourDeals = (deals as any[]).filter(d => d.dealType === 'HAPPY_HOUR');
      const otherDeals = (deals as any[]).filter(d => d.dealType !== 'HAPPY_HOUR');
      // Preserve existing sort inside each group (distance or createdAt formatting kept earlier)
      deals = [...happyHourDeals, ...otherDeals];
    }

    res.status(200).json({
      deals,
      total: deals.length,
      filters: {
        latitude: latitude ? parseFloat(latitude as string) : null,
        longitude: longitude ? parseFloat(longitude as string) : null,
        radius: radius ? parseFloat(radius as string) : null,
        category: category ? category as string : null,
        search: search ? search as string : null,
        cityId: cityId ? Number(cityId) : null,
        today: todayName
      }
    });
  } catch (error) {
    console.error('Error fetching deals:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/deals/categories ---
// Returns all available deal categories
router.get('/deals/categories', async (req, res) => {
  try {
    const categories = [
      { 
        value: 'FOOD_AND_BEVERAGE', 
        label: 'Food & Beverage',
        description: 'Restaurants, cafes, bars, food delivery',
        icon: '🍽️'
      },
      { 
        value: 'RETAIL', 
        label: 'Retail',
        description: 'Clothing, electronics, general merchandise',
        icon: '🛍️'
      },
      { 
        value: 'ENTERTAINMENT', 
        label: 'Entertainment',
        description: 'Movies, events, activities, gaming',
        icon: '🎬'
      },
      { 
        value: 'HEALTH_AND_FITNESS', 
        label: 'Health & Fitness',
        description: 'Gyms, wellness, medical services',
        icon: '💪'
      },
      { 
        value: 'BEAUTY_AND_SPA', 
        label: 'Beauty & Spa',
        description: 'Salons, spas, beauty services',
        icon: '💅'
      },
      { 
        value: 'AUTOMOTIVE', 
        label: 'Automotive',
        description: 'Car services, dealerships, auto parts',
        icon: '🚗'
      },
      { 
        value: 'TRAVEL', 
        label: 'Travel',
        description: 'Hotels, flights, vacation packages',
        icon: '✈️'
      },
      { 
        value: 'EDUCATION', 
        label: 'Education',
        description: 'Courses, training, educational services',
        icon: '📚'
      },
      { 
        value: 'TECHNOLOGY', 
        label: 'Technology',
        description: 'Software, gadgets, tech services',
        icon: '💻'
      },
      { 
        value: 'HOME_AND_GARDEN', 
        label: 'Home & Garden',
        description: 'Furniture, gardening, home improvement',
        icon: '🏠'
      },
      { 
        value: 'OTHER', 
        label: 'Other',
        description: 'Miscellaneous deals',
        icon: '📦'
      }
    ];

    res.status(200).json({
      categories,
      total: categories.length,
      metadata: {
        lastUpdated: new Date().toISOString(),
        version: '1.0.0'
      }
    });
  } catch (error) {
    console.error('Error fetching categories:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/deals/featured ---
// Returns a small set of "hottest" deals for homepage hero sections.
// Strategy:
//  1. Active HAPPY_HOUR deals ending soon (soonest first)
//  2. Then other active deals (RECURRING filtered to today) by higher discount, sooner end
//  3. Limit configurable (?limit=8, default 8, max 20)
router.get('/deals/featured', async (req, res) => {
  try {
    const now = new Date();
    const dayNames = ['SUNDAY','MONDAY','TUESDAY','WEDNESDAY','THURSDAY','FRIDAY','SATURDAY'];
    const todayName = dayNames[now.getDay()];
    const limitParam = parseInt(String(req.query.limit || ''), 10);
    const limit = (!isNaN(limitParam) && limitParam > 0) ? Math.min(limitParam, 20) : 8;

    // Fetch a candidate pool (cap to 100 for performance) of currently active deals
    // Only from approved merchants.
    let candidates = await prisma.deal.findMany({
      where: {
        startTime: { lte: now },
        endTime: { gte: now },
        merchant: { status: 'APPROVED' }
      },
      include: {
        merchant: {
          select: {
            id: true,
            businessName: true,
            address: true,
            description: true,
            logoUrl: true,
            latitude: true,
            longitude: true,
            status: true,
            createdAt: true,
            updatedAt: true,
          }
        }
      },
      orderBy: { endTime: 'asc' }, // early ending first to bias candidate set
      take: 100
    });

    // Filter recurring deals to correct day
    candidates = candidates.filter(d => {
      if (d.dealType !== 'RECURRING') return true;
      if (!d.recurringDays) return false;
      const days = d.recurringDays.split(',').map(s => s.trim().toUpperCase());
      return days.includes(todayName);
    });

    // Compute ranking comparator
    const scored = candidates.map(d => {
      const timeRemainingMs = d.endTime.getTime() - now.getTime();
      const timeRemainingMinutes = timeRemainingMs / 60000;
      const discountPct = d.discountPercentage || 0;
      const discountValue = d.discountAmount || 0;
      // Basic priority groups by deal type
      const typePriority = d.dealType === 'HAPPY_HOUR' ? 3 : (d.dealType === 'RECURRING' ? 2 : 1);
      return { d, timeRemainingMinutes, discountPct, discountValue, typePriority };
    });

    scored.sort((a, b) => {
      // 1. Higher typePriority first (Happy Hour > Recurring > Standard)
      if (b.typePriority !== a.typePriority) return b.typePriority - a.typePriority;
      // 2. For same type: earlier ending first
      if (a.timeRemainingMinutes !== b.timeRemainingMinutes) return a.timeRemainingMinutes - b.timeRemainingMinutes;
      // 3. Higher percentage discount
      if (b.discountPct !== a.discountPct) return b.discountPct - a.discountPct;
      // 4. Higher absolute discount amount
      if (b.discountValue !== a.discountValue) return b.discountValue - a.discountValue;
      // 5. Newer createdAt last tiebreak (newer first)
  return b.d.createdAt.getTime() - a.d.createdAt.getTime();
    });

    const selected = scored.slice(0, limit).map(s => formatDealForFrontend(s.d));

    res.status(200).json({
      deals: selected,
      total: selected.length,
      limit,
      generatedAt: now.toISOString(),
      criteria: {
        prioritized: ['HAPPY_HOUR ending soon', 'RECURRING (today)', 'Others by discount & end time'],
        weekday: todayName
      }
    });
  } catch (error) {
    console.error('Error fetching featured deals:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="src/routes/merchant.routes.ts">
// src/routes/merchant.routes.ts
import { Router } from 'express';
import { protect, isApprovedMerchant, AuthRequest } from '../middleware/auth.middleware';
import prisma from '../lib/prisma';

const router = Router();

// --- Endpoint: POST /api/merchants/register ---
// Allows a user to register as a merchant.
router.post('/merchants/register', protect, async (req: AuthRequest, res) => {
  try {
  const { businessName, address, description, logoUrl, latitude, longitude, cityId } = req.body;
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    if (!businessName || !address) {
      return res.status(400).json({ error: 'Business name and address are required' });
    }

    // Validate coordinates if provided
    if (latitude !== undefined || longitude !== undefined) {
      if (latitude === undefined || longitude === undefined) {
        return res.status(400).json({ error: 'Both latitude and longitude must be provided together' });
      }

      const lat = parseFloat(latitude);
      const lon = parseFloat(longitude);

      if (isNaN(lat) || isNaN(lon)) {
        return res.status(400).json({ error: 'Latitude and longitude must be valid numbers' });
      }

      if (lat < -90 || lat > 90) {
        return res.status(400).json({ error: 'Latitude must be between -90 and 90 degrees' });
      }

      if (lon < -180 || lon > 180) {
        return res.status(400).json({ error: 'Longitude must be between -180 and 180 degrees' });
      }
    }

    const existingMerchant = await prisma.merchant.findUnique({
      where: { ownerId: userId },
    });

    if (existingMerchant) {
      return res.status(409).json({ error: 'You have already registered as a merchant.' });
    }

    // Enforce selection of an existing ACTIVE city (no on-the-fly creation anymore)
    if (!cityId) {
      return res.status(400).json({ error: 'cityId is required. Only pre-approved active cities may be selected.' });
    }
    // @ts-ignore - available after Prisma generate
    const existingCity = await prisma.city.findUnique({ where: { id: Number(cityId) } });
    if (!existingCity) {
      return res.status(400).json({ error: 'Invalid cityId provided.' });
    }
    if (!existingCity.active) {
      return res.status(400).json({ error: 'Selected city is not active for merchant onboarding.' });
    }
    const resolvedCityId: number = existingCity.id;

    const [merchant] = await prisma.$transaction([
      prisma.merchant.create({
        data: {
          businessName,
          address,
          description,
          logoUrl,
          latitude: latitude ? parseFloat(latitude) : null,
          longitude: longitude ? parseFloat(longitude) : null,
          // legacy free-form city usage disabled for new merchants
          city: null,
          owner: { connect: { id: userId } },
        },
      }),
      prisma.user.update({
        where: { id: userId },
        data: { role: 'MERCHANT' },
      }),
    ]);

    // If a city was resolved, create a Store for this merchant
    let store = null as any;
    // @ts-ignore - available after Prisma generate
    store = await prisma.store.create({
      data: {
        merchantId: merchant.id,
        cityId: resolvedCityId,
        address,
        latitude: latitude ? parseFloat(latitude) : null,
        longitude: longitude ? parseFloat(longitude) : null,
      }
    });

    res.status(201).json({
      message: 'Merchant application submitted successfully. It is now pending approval.',
      merchant,
      store,
    });

  } catch (error) {
    console.error('Merchant registration error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/merchants/status ---
// Returns the merchant status for the authenticated user
router.get('/merchants/status', protect, async (req: AuthRequest, res) => {
  try {
    const userId = req.user?.id;

    if (!userId) {
      return res.status(401).json({ error: 'Authentication required' });
    }

    const merchant = await prisma.merchant.findUnique({
      where: { ownerId: userId },
      select: {
        id: true,
        status: true,
        businessName: true,
        address: true,
        description: true,
        logoUrl: true,
        city: true,
        createdAt: true,
        updatedAt: true
      }
    });

    if (!merchant) {
      return res.status(404).json({ error: 'No merchant profile found' });
    }

    res.status(200).json({ merchant });

  } catch (error) {
    console.error('Fetch merchant status error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: POST /api/deals ---
// Allows an APPROVED merchant to create a new deal.
router.post('/deals', protect, isApprovedMerchant, async (req: AuthRequest, res) => {
  try {
    const {
      title,
      description,
      startTime,
      endTime,
      redemptionInstructions,
      discountPercentage,
      discountAmount,
      category,
      dealType: rawDealType,
      recurringDays: rawRecurringDays
    } = req.body;
    const merchantId = req.merchant?.id; // from middleware

    // Basic required fields
    if (!title || !description || !startTime || !endTime) {
      return res.status(400).json({ error: 'Title, description, startTime, endTime are required.' });
    }

    // Normalize deal type (allow human friendly input like "Happy Hour", case-insensitive)
    const validDealTypes = ['STANDARD', 'HAPPY_HOUR', 'RECURRING'] as const;
    let dealType: string = 'STANDARD';
    if (rawDealType) {
      const normalized = String(rawDealType)
        .trim()
        .toUpperCase()
        .replace(/\s+/g, '_'); // "Happy Hour" -> "HAPPY_HOUR"
      if (!validDealTypes.includes(normalized as any)) {
        return res.status(400).json({
          error: `Invalid dealType. Must be one of: ${validDealTypes.join(', ')}`
        });
      }
      dealType = normalized;
    }

    // Validate category if provided
    if (category) {
      const validCategories = [
        'FOOD_AND_BEVERAGE', 'RETAIL', 'ENTERTAINMENT', 'HEALTH_AND_FITNESS',
        'BEAUTY_AND_SPA', 'AUTOMOTIVE', 'TRAVEL', 'EDUCATION', 'TECHNOLOGY',
        'HOME_AND_GARDEN', 'OTHER'
      ];
      if (!validCategories.includes(category)) {
        return res.status(400).json({
          error: `Invalid category. Must be one of: ${validCategories.join(', ')}`
        });
      }
    }

    // Normalize recurringDays: accept array ["MONDAY", "TUESDAY"] OR comma separated string
    const validDays = ['MONDAY', 'TUESDAY', 'WEDNESDAY', 'THURSDAY', 'FRIDAY', 'SATURDAY', 'SUNDAY'];
    let recurringDays: string | null = null;
    if (rawRecurringDays !== undefined && rawRecurringDays !== null && rawRecurringDays !== '') {
      let daysArray: string[] = [];
      if (Array.isArray(rawRecurringDays)) {
        daysArray = rawRecurringDays.map(d => String(d).trim().toUpperCase());
      } else if (typeof rawRecurringDays === 'string') {
        daysArray = rawRecurringDays.split(',').map(d => d.trim().toUpperCase()).filter(Boolean);
      } else {
        return res.status(400).json({ error: 'recurringDays must be an array of days or a comma-separated string.' });
      }

      // Remove duplicates while preserving order
      const seen = new Set<string>();
      daysArray = daysArray.filter(d => { if (!seen.has(d)) { seen.add(d); return true; } return false; });

      const invalidDays = daysArray.filter(d => !validDays.includes(d));
      if (invalidDays.length) {
        return res.status(400).json({ error: `Invalid recurringDays: ${invalidDays.join(', ')}. Must be within ${validDays.join(', ')}` });
      }
      if (daysArray.length === 0) {
        return res.status(400).json({ error: 'recurringDays cannot be empty if provided.' });
      }
      recurringDays = daysArray.join(',');
    }

    // Enforce recurringDays presence only when dealType=RECURRING
    if (dealType === 'RECURRING' && !recurringDays) {
      return res.status(400).json({ error: 'recurringDays are required when dealType is RECURRING.' });
    }
    if (dealType !== 'RECURRING') {
      recurringDays = null; // ignore any provided days for non-recurring deals
    }

    // Persist
    const newDeal = await prisma.deal.create({
      data: {
        title,
        description,
        startTime: new Date(startTime),
        endTime: new Date(endTime),
        redemptionInstructions,
        discountPercentage: discountPercentage ? parseInt(discountPercentage, 10) : null,
        discountAmount: discountAmount ? parseFloat(discountAmount) : null,
        category: category || 'OTHER',
        dealType: dealType as any,
        recurringDays,
        merchant: { connect: { id: merchantId } }
      }
    });

    res.status(201).json({
      message: 'Deal created successfully',
      deal: newDeal,
      normalization: {
        dealType,
        recurringDays: recurringDays ? recurringDays.split(',') : null
      }
    });
  } catch (error) {
    console.error('Deal creation error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: PUT /api/merchants/coordinates ---
// Allows an approved merchant to update their coordinates.
router.put('/merchants/coordinates', protect, isApprovedMerchant, async (req: AuthRequest, res) => {
  try {
    const { latitude, longitude } = req.body;
    const merchantId = req.merchant?.id;

    if (!merchantId) {
      return res.status(401).json({ error: 'Merchant authentication required' });
    }

    // Validate coordinates
    if (latitude === undefined || longitude === undefined) {
      return res.status(400).json({ error: 'Both latitude and longitude are required' });
    }

    const lat = parseFloat(latitude);
    const lon = parseFloat(longitude);

    if (isNaN(lat) || isNaN(lon)) {
      return res.status(400).json({ error: 'Latitude and longitude must be valid numbers' });
    }

    if (lat < -90 || lat > 90) {
      return res.status(400).json({ error: 'Latitude must be between -90 and 90 degrees' });
    }

    if (lon < -180 || lon > 180) {
      return res.status(400).json({ error: 'Longitude must be between -180 and 180 degrees' });
    }

    const updatedMerchant = await prisma.merchant.update({
      where: { id: merchantId },
      data: {
        latitude: lat,
        longitude: lon,
      },
      select: {
        id: true,
        businessName: true,
        latitude: true,
        longitude: true,
        address: true,
      },
    });

    res.status(200).json({
      message: 'Coordinates updated successfully',
      merchant: updatedMerchant,
    });

  } catch (error) {
    console.error('Coordinate update error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/merchants/deals ---
// Returns all deals created by the authenticated (approved) merchant.
// Optional query params:
//   activeOnly=true  -> only deals currently active (start <= now <= end)
//   includeExpired=false (alias; if provided and false, expired filtered out)
router.get('/merchants/deals', protect, isApprovedMerchant, async (req: AuthRequest, res) => {
  try {
    const merchantId = req.merchant?.id;

    if (!merchantId) {
      return res.status(401).json({ error: 'Merchant authentication required' });
    }

    const { activeOnly, includeExpired } = req.query;
    const now = new Date();

    // Fetch all deals for this merchant (dashboard view)
    const deals = await prisma.deal.findMany({
      where: { merchantId },
      orderBy: { createdAt: 'desc' },
      select: {
        id: true,
        title: true,
        description: true,
        category: true,
        discountPercentage: true,
        discountAmount: true,
        startTime: true,
        endTime: true,
        redemptionInstructions: true,
        createdAt: true,
        updatedAt: true,
      }
    });

    // Derive status flags
    const enriched = deals.map(d => {
      const isActive = d.startTime <= now && d.endTime >= now;
      const isExpired = d.endTime < now;
      const isUpcoming = d.startTime > now;
      return { ...d, isActive, isExpired, isUpcoming };
    });

    // Filtering logic
    let filtered = enriched;
    const activeOnlyFlag = (typeof activeOnly === 'string' && activeOnly.toLowerCase() === 'true');
    const includeExpiredFlag = (typeof includeExpired === 'string') ? includeExpired.toLowerCase() === 'true' : true; // default include

    if (activeOnlyFlag) {
      filtered = filtered.filter(d => d.isActive);
    } else if (!includeExpiredFlag) {
      filtered = filtered.filter(d => !d.isExpired);
    }

    const counts = {
      total: enriched.length,
      active: enriched.filter(d => d.isActive).length,
      expired: enriched.filter(d => d.isExpired).length,
      upcoming: enriched.filter(d => d.isUpcoming).length
    };

    res.status(200).json({
      deals: filtered,
      counts,
      filters: {
        activeOnly: activeOnlyFlag,
        includeExpired: includeExpiredFlag
      }
    });

  } catch (error) {
    console.error('Merchant deals fetch error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;

// --- Endpoint: GET /api/merchants/stores ---
// List stores for the authenticated approved merchant
router.get('/merchants/stores', protect, isApprovedMerchant, async (req: AuthRequest, res) => {
  try {
    const merchantId = req.merchant?.id;
    if (!merchantId) return res.status(401).json({ error: 'Merchant authentication required' });
    // @ts-ignore
    const stores = await prisma.store.findMany({ where: { merchantId }, include: { city: true } });
    res.status(200).json({ total: stores.length, stores });
  } catch (e) {
    console.error('List stores failed', e);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: POST /api/merchants/stores ---
// Create a new store for the authenticated approved merchant
// Body: { address, latitude?, longitude?, cityId? OR (cityName & state), active? }
router.post('/merchants/stores', protect, isApprovedMerchant, async (req: AuthRequest, res) => {
  try {
    const merchantId = req.merchant?.id;
    if (!merchantId) return res.status(401).json({ error: 'Merchant authentication required' });

    const { address, latitude, longitude, cityId, active } = req.body || {};
    if (!address) return res.status(400).json({ error: 'address is required' });
    if (!cityId) return res.status(400).json({ error: 'cityId is required. Only existing active cities may be used.' });
    // @ts-ignore
    const existing = await prisma.city.findUnique({ where: { id: Number(cityId) } });
    if (!existing) return res.status(400).json({ error: 'Invalid cityId' });
    if (!existing.active) return res.status(400).json({ error: 'City is not active.' });
    const resolvedCityId: number = existing.id;

    const lat = latitude !== undefined && latitude !== null && String(latitude) !== '' ? parseFloat(latitude) : null;
    const lon = longitude !== undefined && longitude !== null && String(longitude) !== '' ? parseFloat(longitude) : null;
    if (lat !== null && (isNaN(lat) || lat < -90 || lat > 90)) return res.status(400).json({ error: 'Latitude must be a number between -90 and 90' });
    if (lon !== null && (isNaN(lon) || lon < -180 || lon > 180)) return res.status(400).json({ error: 'Longitude must be a number between -180 and 180' });

    // @ts-ignore
    const store = await prisma.store.create({
      data: {
        merchantId,
  cityId: resolvedCityId,
        address,
        latitude: lat,
        longitude: lon,
        active: typeof active === 'boolean' ? active : true,
      },
      include: { city: true }
    });
    res.status(201).json({ message: 'Store created', store });
  } catch (e) {
    console.error('Create store failed', e);
    res.status(500).json({ error: 'Internal server error' });
  }
});
</file>

<file path="src/routes/user.routes.ts">
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import prisma from '../lib/prisma';
import { protect, AuthRequest } from '../middleware/auth.middleware';
import { getPointConfig } from '../lib/points';
import { invalidateLeaderboardCache } from '../lib/leaderboard/cache';

const router = Router();

// Validation schema for saving a deal
const saveDealSchema = z.object({
  dealId: z.number().int().positive({ message: "Deal ID must be a positive integer" }),
});

// Validation schema for check-in
const checkInSchema = z.object({
  dealId: z.number().int().positive(),
  latitude: z.number().refine(v => v >= -90 && v <= 90, { message: 'Latitude must be between -90 and 90.' }),
  longitude: z.number().refine(v => v >= -180 && v <= 180, { message: 'Longitude must be between -180 and 180.' })
});

// Simple Haversine distance (meters)
function haversineMeters(lat1: number, lon1: number, lat2: number, lon2: number): number {
  const R = 6371000; // meters
  const toRad = (d: number) => d * Math.PI / 180;
  const dLat = toRad(lat2 - lat1);
  const dLon = toRad(lon2 - lon1);
  const a = Math.sin(dLat / 2) ** 2 + Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
  return R * c;
}

// --- Endpoint: POST /api/users/save-deal ---
// Save a deal for the authenticated user
router.post('/save-deal', protect, async (req: AuthRequest, res: Response) => {
  try {
    const { dealId } = saveDealSchema.parse(req.body);
    const userId = req.user!.id;

    // Check if the deal exists
    const deal = await prisma.deal.findUnique({
      where: { id: dealId },
      include: {
        merchant: {
          select: {
            businessName: true,
            status: true
          }
        }
      }
    });

    if (!deal) {
      return res.status(404).json({ error: 'Deal not found' });
    }

    // Check if the deal is from an approved merchant
    if (deal.merchant.status !== 'APPROVED') {
      return res.status(400).json({ 
        error: 'Cannot save deals from unapproved merchants' 
      });
    }

    // Check if the deal is still valid (not expired)
    const now = new Date();
    if (deal.endTime < now) {
      return res.status(400).json({ 
        error: 'Cannot save expired deals' 
      });
    }

    // Check if the user has already saved this deal
    const existingSave = await prisma.userDeal.findUnique({
      where: {
        userId_dealId: {
          userId,
          dealId
        }
      }
    });

    if (existingSave) {
      return res.status(409).json({ 
        error: 'Deal already saved by this user' 
      });
    }

    // Save the deal
    const savedDeal = await prisma.userDeal.create({
      data: {
        userId,
        dealId
      },
      include: {
        deal: {
          include: {
            merchant: {
              select: {
                businessName: true,
                address: true,
                latitude: true,
                longitude: true
              }
            }
          }
        }
      }
    });

    res.status(201).json({
      message: 'Deal saved successfully',
      savedDeal: {
        id: savedDeal.id,
        savedAt: savedDeal.savedAt,
        deal: {
          id: savedDeal.deal.id,
          title: savedDeal.deal.title,
          description: savedDeal.deal.description,
          imageUrl: savedDeal.deal.imageUrl,
          discountPercentage: savedDeal.deal.discountPercentage,
          discountAmount: savedDeal.deal.discountAmount,
          category: savedDeal.deal.category,
          dealType: savedDeal.deal.dealType,
          recurringDays: savedDeal.deal.recurringDays,
          startTime: savedDeal.deal.startTime,
          endTime: savedDeal.deal.endTime,
          redemptionInstructions: savedDeal.deal.redemptionInstructions,
          merchant: savedDeal.deal.merchant
        }
      }
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.issues });
    }
    console.error('Save deal error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: POST /api/users/check-in ---
// Verifies that an authenticated user is physically near the merchant location for a given deal.
// Body: { dealId: number, latitude: number, longitude: number }
// Response: { dealId, merchantId, distanceMeters, withinRange, thresholdMeters, dealActive }
router.post('/check-in', protect, async (req: AuthRequest, res: Response) => {
  try {
    // Parse & validate input
    const parsed = checkInSchema.safeParse(req.body);
    if (!parsed.success) {
      return res.status(400).json({ errors: parsed.error.issues });
    }
    const { dealId, latitude, longitude } = parsed.data;
    const userId = req.user!.id;

    // Fetch deal with merchant location
    const deal = await prisma.deal.findUnique({
      where: { id: dealId },
      include: {
        merchant: { select: { id: true, status: true, latitude: true, longitude: true } }
      }
    });

    if (!deal) {
      return res.status(404).json({ error: 'Deal not found' });
    }

    if (deal.merchant.status !== 'APPROVED') {
      return res.status(400).json({ error: 'Deal merchant is not approved' });
    }

    if (deal.merchant.latitude == null || deal.merchant.longitude == null) {
      return res.status(400).json({ error: 'Merchant location not set; cannot perform check-in.' });
    }

    const now = new Date();
    const dealActive = deal.startTime <= now && deal.endTime >= now;
    if (!dealActive) {
      return res.status(400).json({ error: 'Deal is not currently active.' });
    }

    // Distance calculation
    const distanceMeters = haversineMeters(latitude, longitude, deal.merchant.latitude, deal.merchant.longitude);

    const { checkInRadiusMeters, checkInPoints, firstCheckInBonus } = getPointConfig();

    const thresholdMeters = checkInRadiusMeters;
    const withinRange = distanceMeters <= thresholdMeters;

    if (!withinRange) {
      return res.status(200).json({
        dealId: deal.id,
        merchantId: deal.merchant.id,
        userId,
        distanceMeters: Math.round(distanceMeters * 100) / 100,
        withinRange,
        thresholdMeters,
        dealActive,
        pointsAwarded: 0,
        pointEvents: []
      });
    }

    const result = await prisma.$transaction(async (tx) => {
      // Check if user has an existing check-in for this deal
      const priorCheckIn = await tx.checkIn.findFirst({
        where: { userId, dealId: deal.id },
        select: { id: true }
      });

      // Create check-in record
      const checkIn = await tx.checkIn.create({
        data: {
          userId,
          dealId: deal.id,
          merchantId: deal.merchant.id,
          latitude,
          longitude,
          distanceMeters
        }
      });

      let totalAward = checkInPoints;
      const events: any[] = [];

      // Award first-checkin bonus if none exists
      if (!priorCheckIn) {
        totalAward += firstCheckInBonus;
        events.push(await tx.userPointEvent.create({
          data: {
            userId,
            dealId: deal.id,
            type: 'FIRST_CHECKIN_DEAL',
            points: firstCheckInBonus
          }
        }));
      }

      // Always log generic check-in points
      events.push(await tx.userPointEvent.create({
        data: {
          userId,
          dealId: deal.id,
          type: 'CHECKIN',
          points: checkInPoints
        }
      }));

      // Increment user total points
      await tx.user.update({
        where: { id: userId },
        data: ({ points: { increment: totalAward }, monthlyPoints: { increment: totalAward } } as any)
      });

      return { checkIn, totalAward, events, prior: !!priorCheckIn };
    });

  // Invalidate relevant caches (current month/day/week)
  invalidateLeaderboardCache('day');
  invalidateLeaderboardCache('month');
  invalidateLeaderboardCache('week');

    return res.status(200).json({
      dealId: deal.id,
      merchantId: deal.merchant.id,
      userId,
      distanceMeters: Math.round(distanceMeters * 100) / 100,
      withinRange: true,
      thresholdMeters,
      dealActive,
      pointsAwarded: result.totalAward,
      firstCheckIn: !result.prior,
      pointEvents: result.events.map(e => ({ id: e.id, type: e.type, points: e.points }))
    });
  } catch (error) {
    console.error('Check-in error:', error);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: DELETE /api/users/save-deal/:dealId ---
// Remove a saved deal for the authenticated user
router.delete('/save-deal/:dealId', protect, async (req: AuthRequest, res: Response) => {
  try {
    const dealId = parseInt(req.params.dealId);
    const userId = req.user!.id;

    if (isNaN(dealId)) {
      return res.status(400).json({ error: 'Invalid deal ID' });
    }

    // Check if the user has saved this deal
    const savedDeal = await prisma.userDeal.findUnique({
      where: {
        userId_dealId: {
          userId,
          dealId
        }
      }
    });

    if (!savedDeal) {
      return res.status(404).json({ 
        error: 'Deal not found in your saved deals' 
      });
    }

    // Remove the saved deal
    await prisma.userDeal.delete({
      where: {
        userId_dealId: {
          userId,
          dealId
        }
      }
    });

    res.status(200).json({
      message: 'Deal removed from saved deals successfully'
    });

  } catch (error) {
    console.error('Remove saved deal error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/users/saved-deals ---
// Get all saved deals for the authenticated user
router.get('/saved-deals', protect, async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;

    const savedDeals = await prisma.userDeal.findMany({
      where: { userId },
      include: {
        deal: {
          include: {
            merchant: {
              select: {
                businessName: true,
                address: true,
                latitude: true,
                longitude: true
              }
            }
          }
        }
      },
      orderBy: {
        savedAt: 'desc'
      }
    });

    // Filter out expired deals and format response
    const now = new Date();
    const activeSavedDeals = savedDeals
      .filter((savedDeal: any) => savedDeal.deal.endTime >= now)
      .map((savedDeal: any) => ({
        id: savedDeal.id,
        savedAt: savedDeal.savedAt,
        deal: {
          id: savedDeal.deal.id,
          title: savedDeal.deal.title,
          description: savedDeal.deal.description,
          imageUrl: savedDeal.deal.imageUrl,
          discountPercentage: savedDeal.deal.discountPercentage,
          discountAmount: savedDeal.deal.discountAmount,
          category: savedDeal.deal.category,
          startTime: savedDeal.deal.startTime,
          endTime: savedDeal.deal.endTime,
          redemptionInstructions: savedDeal.deal.redemptionInstructions,
          merchant: savedDeal.deal.merchant
        }
      }));

    res.status(200).json({
      message: 'Saved deals retrieved successfully',
      savedDeals: activeSavedDeals,
      totalCount: activeSavedDeals.length
    });

  } catch (error) {
    console.error('Get saved deals error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/users/saved-deals/:dealId ---
// Check if a specific deal is saved by the authenticated user
router.get('/saved-deals/:dealId', protect, async (req: AuthRequest, res: Response) => {
  try {
    const dealId = parseInt(req.params.dealId);
    const userId = req.user!.id;

    if (isNaN(dealId)) {
      return res.status(400).json({ error: 'Invalid deal ID' });
    }

    const savedDeal = await prisma.userDeal.findUnique({
      where: {
        userId_dealId: {
          userId,
          dealId
        }
      }
    });

    res.status(200).json({
      isSaved: !!savedDeal,
      savedAt: savedDeal?.savedAt || null
    });

  } catch (error) {
    console.error('Check saved deal error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// --- Endpoint: GET /api/users/referrals ---
// Returns how many users have signed up using the authenticated user's referral code
router.get('/referrals', protect, async (req: AuthRequest, res: Response) => {
  try {
    const userId = req.user!.id;
    // Fetch the user's referral code and count referred users
    const user = await prisma.user.findUnique({
      where: { id: userId },
      // @ts-ignore new field referralCode already in schema
      select: { referralCode: true }
    });
    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }
    // @ts-ignore new field referredByUserId added in migration pending generate
    const referralCount = await prisma.user.count({ where: { referredByUserId: userId } });
    return res.status(200).json({
      referralCode: (user as any).referralCode,
      referralCount
    });
  } catch (err) {
    console.error('Get referrals error:', err);
    return res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

<file path="src/index.ts">
import app from './app';
import { scheduleMonthlyReset } from './jobs/monthlyReset';
import { scheduleDailyBirthdays } from './jobs/dailyBirthday';

const PORT = process.env.PORT || 3000;

app.listen(PORT, () => {
  console.log(`[server]: Server is running at http://localhost:${PORT}`);
  if (process.env.DISABLE_SCHEDULER !== 'true') {
  scheduleMonthlyReset();
  scheduleDailyBirthdays();
  console.log('[scheduler]: Monthly reset scheduled.');
  console.log('[scheduler]: Daily birthdays scheduled.');
  }
});
</file>

<file path="package.json">
{
  "name": "geolocationmvpbackend",
  "version": "1.0.0",
  "main": "index.js",
  "scripts": {
    "dev": "nodemon",
    "build": "tsc",
    "start": "npm run build && node dist/index.js",
    "test": "jest --runInBand",
    "test:ci": "jest --ci --reporters=default --runInBand",
    "backfill:referrals": "ts-node scripts/backfill-referral-codes.ts",
    "seed:cities": "ts-node scripts/seed-cities.ts",
    "db:ensure-city-store": "ts-node scripts/manual-create-city-store.ts",
    "db:ensure-and-seed-cities": "npm run db:ensure-city-store && npm run seed:cities",
    "db:health": "ts-node scripts/db-health-check.ts",
  "seed:cities:retry": "npm run db:health && npm run seed:cities",
  "backfill:merchant:stores": "ts-node scripts/backfill-merchant-stores.ts"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "",
  "dependencies": {
    "@prisma/client": "^6.12.0",
    "axios": "^1.11.0",
    "bcryptjs": "^3.0.2",
    "compression": "^1.7.4",
    "cors": "^2.8.5",
    "dotenv": "^17.2.0",
    "express": "^5.1.0",
    "express-rate-limit": "^7.4.0",
    "helmet": "^7.1.0",
    "jsonwebtoken": "^9.0.2",
    "morgan": "^1.10.0",
    "nodemailer": "^6.9.14",
    "winston": "^3.11.0",
    "winston-daily-rotate-file": "^5.0.0",
    "zod": "^4.0.15"
  },
  "devDependencies": {
    "@types/bcryptjs": "^2.4.6",
    "@types/compression": "^1.7.5",
    "@types/cors": "^2.8.19",
    "@types/express": "^5.0.3",
    "@types/jest": "^29.5.12",
    "@types/jsonwebtoken": "^9.0.10",
    "@types/morgan": "^1.9.9",
    "@types/node": "^24.0.15",
    "@types/nodemailer": "^7.0.1",
    "@types/supertest": "^2.0.16",
    "jest": "^29.7.0",
    "nodemon": "^3.1.10",
    "prisma": "^6.12.0",
    "supertest": "^7.0.0",
    "ts-jest": "^29.2.5",
    "ts-node": "^10.9.2",
    "typescript": "^5.8.3"
  }
}
</file>

<file path="prisma/schema.prisma">
// prisma/schema.prisma

generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// --- ENUMS for controlled values ---

enum UserRole {
  USER
  MERCHANT
  ADMIN
}

enum MerchantStatus {
  PENDING
  APPROVED
  REJECTED
}

enum DealCategory {
  FOOD_AND_BEVERAGE
  RETAIL
  ENTERTAINMENT
  HEALTH_AND_FITNESS
  BEAUTY_AND_SPA
  AUTOMOTIVE
  TRAVEL
  EDUCATION
  TECHNOLOGY
  HOME_AND_GARDEN
  OTHER
}

enum DealType {
  STANDARD
  HAPPY_HOUR
  RECURRING
}

// --- GAMIFICATION ---
enum PointEventType {
  SIGNUP
  FIRST_CHECKIN_DEAL
  CHECKIN
}


// --- CORE MODELS ---

model User {
  id        Int      @id @default(autoincrement())
  email     String   @unique
  name      String?
  password  String
  role      UserRole @default(USER) // All new users start as a regular USER
  // Gamification / reward points accumulated by the user
  points    Int      @default(0)
  // Points accumulated in the current calendar month (UTC) and reset via scheduled job
  monthlyPoints Int  @default(0)
  // Unique, shareable referral code for inviting other users
  referralCode String? @unique
  // The user who referred this user (if any)
  referredByUserId Int?
  referredBy User? @relation("UserReferrals", fields: [referredByUserId], references: [id])
  // Users that this user has referred
  referrals  User[]   @relation("UserReferrals")

  // Birthday (UTC date). Used for sending a simple greeting email. Optional.
  birthday   DateTime?

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // A User can own one Merchant profile
  merchant  Merchant?

  // A User can save many Deals
  savedDeals UserDeal[]

  // Point events log
  pointEvents UserPointEvent[]

  // Check-ins
  checkIns   CheckIn[]

  @@index([referredByUserId])
}

model Merchant {
  id            Int      @id @default(autoincrement())
  businessName  String
  address       String
  description   String?
  logoUrl       String?
  status        MerchantStatus @default(PENDING) // New merchants are PENDING by default
  
  // Geolocation fields
  latitude      Float?
  longitude     Float?
  // Deprecated: use Store.city -> City relation instead
  city          String?

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // A Merchant must be owned by one User
  ownerId       Int      @unique
  owner         User     @relation(fields: [ownerId], references: [id])

  // A Merchant can have many Deals
  deals         Deal[]

  // A Merchant can have multiple physical stores/locations
  stores        Store[]
}

model Deal {
  id            Int      @id @default(autoincrement())
  title         String
  description   String
  imageUrls     String[] // Array of Cloudinary URLs for multiple images

  // Basic deal parameters (can be expanded later)
  discountPercentage Int?
  discountAmount     Float?
  
  // Category for filtering and organization
  category      DealCategory @default(OTHER)
  
  // Deal type for different deal behaviors
  dealType      DealType @default(STANDARD)
  
  // Recurring days for recurring deals (e.g., "Taco Tuesday")
  // Stored as comma-separated values: "MONDAY,TUESDAY,WEDNESDAY"
  recurringDays String?
  
  // Validity period
  startTime     DateTime
  endTime       DateTime
  
  redemptionInstructions String

  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  // Each Deal belongs to one Merchant
  merchantId    Int
  merchant      Merchant @relation(fields: [merchantId], references: [id])

  // A Deal can be saved by many Users
  savedByUsers  UserDeal[]

  // Point events
  pointEvents UserPointEvent[]

  // Check-ins
  checkIns  CheckIn[]
}

// Junction table for User-Deal relationship (saved deals)
model UserDeal {
  id        Int      @id @default(autoincrement())
  userId    Int
  dealId    Int
  savedAt   DateTime @default(now())

  // Relations
  user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  deal      Deal     @relation(fields: [dealId], references: [id], onDelete: Cascade)

  // Ensure a user can only save a deal once
  @@unique([userId, dealId])
}

// Log of points awarded to users for various actions
model UserPointEvent {
  id        Int            @id @default(autoincrement())
  userId    Int
  dealId    Int?
  type      PointEventType
  points    Int
  createdAt DateTime       @default(now())

  user      User           @relation(fields: [userId], references: [id], onDelete: Cascade)
  deal      Deal?          @relation(fields: [dealId], references: [id])

  @@index([userId, type])
  @@index([userId, dealId])
  // Added for efficient time-bounded leaderboard queries
  @@index([createdAt])
  @@index([createdAt, userId])
}

// Individual physical proximity confirmations
model CheckIn {
  id            Int      @id @default(autoincrement())
  userId        Int
  dealId        Int
  merchantId    Int
  latitude      Float
  longitude     Float
  distanceMeters Float
  createdAt     DateTime @default(now())

  user    User @relation(fields: [userId], references: [id], onDelete: Cascade)
  deal    Deal @relation(fields: [dealId], references: [id], onDelete: Cascade)

  @@index([userId, dealId])
  @@index([merchantId])
}

// --- LOCATIONS ---

// Normalized list of cities in the US with state and active flag
model City {
  id        Int       @id @default(autoincrement())
  name      String
  state     String
  active    Boolean   @default(false)
  createdAt DateTime  @default(now())
  updatedAt DateTime  @updatedAt

  // Relations
  stores    Store[]

  @@unique([name, state])
  @@index([active, name])
}

// Individual merchant store locations tied to a City
model Store {
  id         Int       @id @default(autoincrement())
  merchantId Int
  cityId     Int
  address    String
  latitude   Float?
  longitude  Float?
  active     Boolean   @default(true)
  createdAt  DateTime  @default(now())
  updatedAt  DateTime  @updatedAt

  merchant   Merchant  @relation(fields: [merchantId], references: [id], onDelete: Cascade)
  city       City      @relation(fields: [cityId], references: [id])

  @@index([merchantId])
  @@index([cityId])
  @@index([active, cityId])
}
</file>

<file path="src/routes/auth.routes.ts">
import { Router, Request, Response } from 'express';
import { z } from 'zod';
import prisma from '../lib/prisma';
import bcrypt from 'bcryptjs';
import jwt from 'jsonwebtoken';
import { protect, AuthRequest } from '../middleware/auth.middleware';
import { getPointConfig } from '../lib/points';
import { sendWelcomeEmail, sendReferralSuccessEmail } from '../lib/email';
import { invalidateLeaderboardCache } from '../lib/leaderboard/cache';

const router = Router();


// --- Endpoint: POST /api/auth/register ---
const registerSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string().min(8, { message: "Password must be at least 8 characters long" }),
  name: z.string().optional(),
  referralCode: z.string().length(8).optional() // code used during signup
});

router.post('/register', async (req: Request, res: Response) => {
  try {
  const { email, password, name, referralCode } = registerSchema.parse(req.body);
        
        // Normalize email to lowercase to prevent case sensitivity issues
        const normalizedEmail = email.toLowerCase().trim();

    // 2. Check if user already exists
    const existingUser = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (existingUser) {
      return res.status(409).json({ error: 'Email is already in use' });
    }

    // 3. Hash the password
    const hashedPassword = await bcrypt.hash(password, 10); // 10 is the salt rounds

    // 4. Create the new user in the database
    const { signupPoints } = getPointConfig();

    function generateReferralCode(): string {
      // 8-char base36 (excluding easily confusable chars) random code
      const alphabet = 'ABCDEFGHJKMNPQRSTUVWXYZ23456789';
      let code = '';
      for (let i = 0; i < 8; i++) {
        code = code + alphabet[Math.floor(Math.random() * alphabet.length)];
      }
      return code;
    }

  async function getUniqueReferralCode(tx: any): Promise<string> {
      // Retry a few times in the unlikely event of collision
      for (let attempt = 0; attempt < 5; attempt++) {
        const code = generateReferralCode();
    // @ts-ignore referralCode pending prisma generate
    const existing = await tx.user.findFirst({ where: { referralCode: code }, select: { id: true } });
        if (!existing) return code;
      }
      throw new Error('Failed to generate unique referral code after 5 attempts');
    }

  // Using any because generated Prisma types may be stale during migration application
  // and we only need a few selected fields for the email notification.
  let referrerForEmail: any = null;
  const newUser = await prisma.$transaction(async (tx) => {
      const referralCode = await getUniqueReferralCode(tx);
      // If user supplied a referral code, fetch referrer
      let referredByUserId: number | undefined = undefined;
      if (req.body.referralCode) {
    referrerForEmail = await tx.user.findFirst({ where: { referralCode: req.body.referralCode }, select: { id: true, email: true, name: true, referralCode: true } });
    if (referrerForEmail) referredByUserId = referrerForEmail.id;
      }
      const created = await tx.user.create({
        data: {
          email: normalizedEmail,
          name,
          password: hashedPassword,
          points: signupPoints,
          // @ts-ignore new field added in migration; prisma generate pending
          monthlyPoints: signupPoints,
          // @ts-ignore new field added in migration; prisma generate pending
          referralCode,
          // @ts-ignore new field added in migration; prisma generate pending
          referredByUserId
        } as any,
      });
      await tx.userPointEvent.create({
        data: {
          userId: created.id,
          type: 'SIGNUP',
          points: signupPoints
        }
      });
  // Invalidate monthly & day caches (signup only affects current period aggregates)
  invalidateLeaderboardCache('month');
  invalidateLeaderboardCache('day');
      return created;
    });

    // We don't want to send the password back, even the hashed one
    const { password: _, ...userWithoutPassword } = newUser;

    // Fire & forget welcome email (non-blocking)
    sendWelcomeEmail(userWithoutPassword.email, userWithoutPassword.name || undefined).catch(err => {
      console.error('[email] welcome send error', err);
    });

    // Fire & forget referral success email to referrer (if any)
    if (referrerForEmail) {
      const r = referrerForEmail; // narrow for TS
      sendReferralSuccessEmail({
        to: r.email,
        referrerName: r.name || undefined,
        referredEmail: userWithoutPassword.email,
        referralCode: r.referralCode || 'UNKNOWN'
      }).catch(err => console.error('[email] referral-success send error', err));
    }

    // 5. Send back a success response
    res.status(201).json({
      message: 'User created successfully',
      user: userWithoutPassword,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.issues });
    }
    console.error('Registration error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});



router.get('/me', protect, async (req: AuthRequest, res: Response) => {
  try {
  const userId = req.user?.id;
    const user = await prisma.user.findUnique({
      where: { id: userId },
      // @ts-ignore new field added in migration; prisma generate pending
      select: { id: true, email: true, name: true, createdAt: true, points: true, referralCode: true, role: true }, 
    });

    if (!user) {
      return res.status(404).json({ error: 'User not found' });
    }

    res.status(200).json(user);
  } catch (error) {
    console.error('Get me error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});




// --- Endpoint: POST /api/auth/login ---
const loginSchema = z.object({
  email: z.string().email({ message: "Invalid email address" }),
  password: z.string(),
});

router.post('/login', async (req: Request, res: Response) => {
  try {
        const { email, password } = loginSchema.parse(req.body);
        
        // Normalize email to lowercase to prevent case sensitivity issues
        const normalizedEmail = email.toLowerCase().trim();

    // 2. Find the user by email
    const user = await prisma.user.findUnique({ where: { email: normalizedEmail } });
    if (!user) {
      // Use a generic error message for security
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // 3. Compare the submitted password with the stored hash
    const isPasswordValid = await bcrypt.compare(password, user.password);
    if (!isPasswordValid) {
      return res.status(401).json({ error: 'Invalid credentials' });
    }

    // 4. Generate a JWT
    const jwtSecret = process.env.JWT_SECRET;
    if (!jwtSecret) {
      throw new Error('JWT_SECRET is not defined in the .env file');
    }

    const token = jwt.sign(
      { userId: user.id, email: user.email }, // This is the JWT payload
      jwtSecret,
      { expiresIn: '24h' } // Token will expire in 24 hours
    );

    // 5. Send the token back to the client
    res.status(200).json({
      message: 'Login successful',
      token: token,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ errors: error.issues });
    }
    console.error('Login error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

export default router;
</file>

</files>
